var documenterSearchIndex = {"docs":
[{"location":"signal/#Simulate-MR-Signal","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"","category":"section"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"In this example we are going to generate a phantom and simulate the signal for a gradient-balanced sequence with a Cartesian gradient trajectory","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"using Revise\nusing BlochSimulators\nusing ComputationalResources\nusing StaticArrays\nusing LinearAlgebra\nusing PyPlot\nusing FFTW\nimport ImagePhantoms","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"First we assemble a Shepp Logan phantom with homogeneous T₁ and T₂ but non-constant proton density and B₀","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"N = 256\nρ = complex.(ImagePhantoms.shepp_logan(N, ImagePhantoms.SheppLoganEmis())');\nT₁ = fill(0.85, N, N);\nT₂ = fill(0.05, N, N);\nB₀ = repeat(1:N,1,N);","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"We also set the spatial coordinates for the phantom","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"FOVˣ, FOVʸ = 25.6, 25.6;\nX = [x for x ∈ LinRange(-FOVˣ/2, FOVˣ/2, N), y ∈ 1:N];\nY = [y for x ∈ 1:N, y ∈ LinRange(-FOVʸ/2, FOVʸ/2, N)];","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"Finally we assemble the phantom as an array of T₁T₂B₀ρˣρʸxy values","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"parameters = map(T₁T₂B₀ρˣρʸxy, T₁, T₂, B₀, real.(ρ), imag.(ρ), X, Y);","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"Next, we assemble a balanced sequence with constant flip angle of 60 degrees, a TR of 10 ms and 0-π phase cycling. See src/sequences/pssfp.jl for the sequence description and the fields for which values must be provided","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"nTR = N\nRF_train = complex.(fill(40.0, nTR)) # constant flip angle train\nRF_train[2:2:end] .*= -1 # 0-π phase cycling\nnRF = 25 # nr of RF discretization points\ndurRF = 0.001 # duration of RF excitation\nTR = 0.010 # repetition time\nTI = 10.0 # long inversion delay -> no inversion\ngaussian = [exp(-(i-(nRF/2))^2 * inv(nRF)) for i ∈ 1:nRF] # RF excitation waveform\nγΔtRF = (π/180) * normalize(gaussian, 1) |> SVector{nRF} # normalize to flip angle of 1 degree\nΔt = (ex=durRF/nRF, inv = TI, pr = (TR - durRF)/2); # time intervals during TR\nγΔtGRz = (ex=0.002/nRF, inv = 0.00, pr = -0.01); # slice select gradient strengths during TR\nnz = 35 # nr of spins in z direction\nz = SVector{nz}(LinRange(-1,1,nz)) # z locations\n\nsequence = pSSFP(RF_train, TR, γΔtRF, Δt, γΔtGRz, z)","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"Next, we assemble a Cartesian trajectory with linear phase encoding (see src/trajectories/cartesian.jl).","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"nr = N # nr of readouts\nns = N # nr of samples per readout\nΔt_adc = 10^-5 # time between sample points\npy = -(N÷2):1:(N÷2)-1 # phase encoding indices\nΔkˣ = 2π / FOVˣ; # k-space step in x direction for Nyquist sampling\nΔkʸ = 2π / FOVʸ; # k-space step in y direction for Nyquist sampling\nk0 = [(-ns/2 * Δkˣ) + im * (py[r] * Δkʸ) for r in 1:nr]; # starting points in k-space per readout\nΔk = [Δkˣ + 0.0im for r in 1:nr]; # k-space steps per sample point for each readout\n\ntrajectory = CartesianTrajectory(nr,ns,Δt_adc,k0,Δk,py);","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"We use two different receive coils","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"coil₁ = complex.(repeat(LinRange(0.5,1.0,N),1,N));\ncoil₂ = coil₁';\n\ncoil_sensitivities = map(SVector, coil₁, coil₂)","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"Now simulate the signal for the sequence, trajectory, phantom and coils on GPU","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"resource = CUDALibs()\n\nsequence            = gpu(f32(sequence))\nparameters          = gpu(f32(parameters))\ntrajectory          = gpu(f32(trajectory))\ncoil_sensitivities  = gpu(f32(coil_sensitivities))\n\nsignal = simulate(CUDALibs(), sequence, parameters, trajectory, coil_sensitivities)\n\nsignal = collect(signal)","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"Let's look at fft images of the signals from the two different coils","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"signal₁ = first.(signal)\nsignal₂ = last.(signal)\n\n\n@. signal₁[2:2:end] *= -1 # correct for phase cycling\n@. signal₂[2:2:end] *= -1 # correct for phase cycling\n\nfft_image₁ = rot180(ifft(reshape(signal₁,N,N))) # rot180 instead of fftshifts\nfft_image₂ = rot180(ifft(reshape(signal₂,N,N))) # rot180 instead of fftshifts\n\nfigure()\nsubplot(1,3,1); imshow(abs.(ρ)); title(\"Ground truth \\n proton density\")\nsubplot(1,3,2); imshow(abs.(fft_image₁)); title(\"fft-image coil 1\")\nsubplot(1,3,3); imshow(abs.(fft_image₂)); title(\"fft-image coil 2\")","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"Note the banding due to off-resonance","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = BlochSimulators","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Isochromat-Operators","page":"API","title":"Isochromat Operators","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Isochromat","category":"page"},{"location":"api/#BlochSimulators.Isochromat","page":"API","title":"BlochSimulators.Isochromat","text":"struct Isochromat{T<:Real} <: FieldVector{3,T}\n    x::T\n    y::T\n    z::T\nend\n\nHolds the x,y,z components of a spin isochromat in a FieldVector, which is a StaticVector (from the package StaticArrays) with custom fieldnames.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"operators/isochromat.jl\"]","category":"page"},{"location":"api/#BlochSimulators.decay-Union{Tuple{T}, Tuple{BlochSimulators.Isochromat{T}, Any, Any}} where T","page":"API","title":"BlochSimulators.decay","text":"decay(m::Isochromat{T}, E₁, E₂) where T\n\nApply T₂ decay to transverse component and T₁ decay to longitudinal component of Isochromat.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.initialize_states-Union{Tuple{T}, Tuple{ComputationalResources.AbstractResource, IsochromatSimulator{T}}} where T","page":"API","title":"BlochSimulators.initialize_states","text":"initialize_states(::AbstractResource, ::IsochromatSimulator{T}) where T\n\nInitialize a spin isochromat to be used throughout a simulation of the sequence.\n\nThis may seem redundant but to is necessary to share the same programming interface with EPGSimulators.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.invert-Union{Tuple{BlochSimulators.Isochromat{T}}, Tuple{T}} where T","page":"API","title":"BlochSimulators.invert","text":"invert(m::Isochromat{T}, p::AbstractTissueParameters) where T\n\nInvert Isochromat with B₁ insenstive (i.e. adiabatic) inversion pulse\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.invert-Union{Tuple{T}, Tuple{BlochSimulators.Isochromat{T}, AbstractTissueParameters}} where T","page":"API","title":"BlochSimulators.invert","text":"invert(m::Isochromat{T}, p::AbstractTissueParameters) where T\n\nInvert z-component of Isochromat (assuming spoiled transverse magnetization so xy-component zero).\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.regrowth-Union{Tuple{T}, Tuple{BlochSimulators.Isochromat{T}, Any}} where T","page":"API","title":"BlochSimulators.regrowth","text":"regrowth(m::Isochromat{T}, E₁) where T\n\nApply T₁ regrowth to longitudinal component of Isochromat.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.rotate-Tuple{BlochSimulators.Isochromat, Any, Any, Any, AbstractTissueParameters}","page":"API","title":"BlochSimulators.rotate","text":"rotate(m::Isochromat, γΔtGRz, z, Δt, p::AbstractTissueParameters)\n\nRotation of Isochromat without RF (so around z-axis only) due to gradients and B0 (i.e. refocussing slice select gradient).\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.rotate-Union{Tuple{T}, Tuple{BlochSimulators.Isochromat{T}, Any, Any, Any, Any, AbstractTissueParameters}} where T","page":"API","title":"BlochSimulators.rotate","text":"rotate(m::Isochromat{T}, γΔtRF::Complex, γΔtGR::Tuple, (x,y,z), Δt, p::AbstractTissueParameters) where T\n\nRF, gradient and/or ΔB₀ induced rotation of Isochromat computed using Rodrigues rotation formula (https://en.wikipedia.org/wiki/Rodrigues%27rotationformula).\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.sample_transverse!-Tuple{Any, Union{Integer, CartesianIndex}, BlochSimulators.Isochromat}","page":"API","title":"BlochSimulators.sample_transverse!","text":"sample!(output, index::Union{Integer,CartesianIndex}, m::Isochromat)\n\nSample transverse magnetization from Isochromat. The \"+=\" is needed for 2D sequences where slice profile is taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.sample_xyz!-Union{Tuple{S}, Tuple{AbstractArray{<:S}, Union{Integer, CartesianIndex}, BlochSimulators.Isochromat}} where S","page":"API","title":"BlochSimulators.sample_xyz!","text":"sample_xyz!(output, index::Union{Integer,CartesianIndex}, m::Isochromat)\n\nSample m.x, m.y and m.z components from Isochromat. The \"+=\" is needed for 2D sequences where slice profile is taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api/#EPG-Operators","page":"API","title":"EPG Operators","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"EPGStates","category":"page"},{"location":"api/#BlochSimulators.EPGStates","page":"API","title":"BlochSimulators.EPGStates","text":"EPGStates = Union{MMatrix{3}, SizedMatrix{3}}\n\nIn the EPG model, the configuration state matrix Ω will be updated inplace. On CPU, we use StaticArrays.MMatrix. The MMatrix will not escape _simulate! and therefore should not result in allocations. On GPU, we use shared memory (CUDA.CuStaticSharedArray). The shared memory is allocated for all threads within a block simultaneously. We then take a @view and wrap it in a SizedArray. Without the SizedArray, the type would be long and unreadable. By wrapping, we can then simply dispatch on a SizedArray instead.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"operators/epg.jl\"]","category":"page"},{"location":"api/#BlochSimulators.F̄₋-Tuple{Any}","page":"API","title":"BlochSimulators.F̄₋","text":"F̄₋(Ω)\n\nView into the second row of the configuration state matrix Ω, corresponding to the F̄₋ states.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.F₊-Tuple{Any}","page":"API","title":"BlochSimulators.F₊","text":"F₊(Ω)\n\nView into the first row of the configuration state matrix Ω, corresponding to the F₊ states.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.Z-Tuple{Any}","page":"API","title":"BlochSimulators.Z","text":"Z(Ω)\n\nView into the third row of the configuration state matrix Ω, corresponding to the Z states.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.decay!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData<:AbstractArray{T, M}}}, Any, Any}","page":"API","title":"BlochSimulators.decay!","text":"decay!(Ω::EPGStates, E₁, E₂)\n\nT₂ decay for F-components, T₁ decay for Z-component of each state.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.dephasing!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData<:AbstractArray{T, M}}}}","page":"API","title":"BlochSimulators.dephasing!","text":"dephasing!(Ω::EPGStates)\n\nShift states around due to dephasing gradient: The F₊ go up one, the F̄₋ go down one and Z do not change\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.excite!-Union{Tuple{T}, Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData<:AbstractArray{T, M}}}, T, AbstractTissueParameters}} where T<:Union{Complex, Unitful.Quantity{<:Complex}}","page":"API","title":"BlochSimulators.excite!","text":"excite!(Ω::EPGStates, RF::Complex, p::AbstractTissueParameters)\n\nMixing of states due to RF pulse. Magnitude of RF is the flip angle in degrees. Phase of RF is the phase of the pulse. If RF is real, the computations simplify a little bit.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.initial_conditions!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData<:AbstractArray{T, M}}}}","page":"API","title":"BlochSimulators.initial_conditions!","text":"initial_conditions!(Ω::EPGStates)\n\nSet all components of all states to 0, except the Z-component of the 0th state which is set to 1.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.initialize_states-Union{Tuple{Ns}, Tuple{T}, Tuple{ComputationalResources.AbstractResource, EPGSimulator{T, Ns}}} where {T, Ns}","page":"API","title":"BlochSimulators.initialize_states","text":"initialize_states(::AbstractResource, sequence::EPGSimulator{T,Ns}) where {T,Ns}\n\nInitialize an MMatrix of EPG states on CPU to be used throughout the simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.initialize_states-Union{Tuple{Ns}, Tuple{T}, Tuple{ComputationalResources.CUDALibs, EPGSimulator{T, Ns}}} where {T, Ns}","page":"API","title":"BlochSimulators.initialize_states","text":"initialize_states(::CUDALibs, sequence::EPGSimulator{T,Ns}) where {T,Ns}\n\nInitialize an array of EPG states on a CUDA GPU to be used throughout the simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.invert!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData<:AbstractArray{T, M}}}, AbstractTissueParameters}","page":"API","title":"BlochSimulators.invert!","text":"invert!(Ω::EPGStates, p::AbstractTissueParameters)\n\nInvert Z-component of 0th order state (assuming spoiled transverse magnetization so xy-component zero and no population of higher order Z states).\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.invert!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData<:AbstractArray{T, M}}}}","page":"API","title":"BlochSimulators.invert!","text":"invert!(Ω::EPGStates)\n\nInvert with B₁ insenstive (i.e. adiabatic) inversion pulse\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.regrowth!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData<:AbstractArray{T, M}}}, Any}","page":"API","title":"BlochSimulators.regrowth!","text":"regrowth!(Ω::EPGStates, E₁)\n\nT₁ regrowth for Z-component of 0th order state.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.rotate!-Union{Tuple{T}, Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData<:AbstractArray{T, M}}}, T}} where T","page":"API","title":"BlochSimulators.rotate!","text":"rotate!(Ω::EPGStates, eⁱᶿ::T) where T\n\nRotate F₊ and F̄₋ states under the influence of eⁱᶿ = exp(i * ΔB₀ * Δt)\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.rotate_decay!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData<:AbstractArray{T, M}}}, Any, Any, Any}","page":"API","title":"BlochSimulators.rotate_decay!","text":"rotate_decay!(Ω::EPGStates, E₁, E₂, eⁱᶿ)\n\nRotate and decay combined\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.sample_transverse!-Tuple{Any, Union{Integer, CartesianIndex}, Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData<:AbstractArray{T, M}}}}","page":"API","title":"BlochSimulators.sample_transverse!","text":"sample_transverse!(output, index::Union{Integer,CartesianIndex}, Ω::EPGStates)\n\nSample the measurable transverse magnetization, that is, the F₊ component of the 0th state. The += is needed for 2D sequences where slice profile is taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.sample_Ω!-Tuple{Any, Union{Integer, CartesianIndex}, Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData<:AbstractArray{T, M}}}}","page":"API","title":"BlochSimulators.sample_Ω!","text":"sample_Ω!(output, index::Union{Integer,CartesianIndex}, Ω::EPGStates)\n\nSample the entire configuration state matrix Ω. The += is needed for 2D sequences where slice profile is taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.Ω_eltype-Union{Tuple{EPGSimulator{T, Ns}}, Tuple{Ns}, Tuple{T}} where {T, Ns}","page":"API","title":"BlochSimulators.Ω_eltype","text":"Ω_eltype(sequence::EPGSimulator{T,Ns}) where {T,Ns} = Complex{T}\n\nBy default, configuration states are complex. For some sequences, they will only ever be real (no RF phase, no complex slice profile correction) and for these sequences a method needs to be added to this function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tissue-Parameters","page":"API","title":"Tissue Parameters","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractTissueParameters","category":"page"},{"location":"api/#BlochSimulators.AbstractTissueParameters","page":"API","title":"BlochSimulators.AbstractTissueParameters","text":"AbstractTissueParameters{N,T} <: FieldVector{N,T}\n\nAbstract type for structs that hold different combinations of tissue parameters.\n\nPossible fields\n\nT₁::T: T₁ relaxation parameters of a voxel\nT₂::T: T₂ relaxation parameters of a voxel\nB₁::T: Scaling factor for effective B₁ excitation field within a voxel\nB₀::T: Off-resonance with respect to main magnetic field within a voxel\nρˣ::T: Real part of proton density within a voxel\nρʸ::T: Imaginary part of proton density within a voxel\nx::T: Position of voxel along the x direction\ny::T: Position of voxel along the y direction\nz::T: Position of voxel along the z direction\n\nThe structs are subtypes of FieldVector, which is a StaticVector with named fields (see the documentation of StaticArrays.jl). There are three reasons for letting the structs be subtypes of FieldVector:\n\nFieldVectors/StaticVectors have sizes that are known at compile time. This is beneficial for performance reasons\nThe named fields improve readability of the code (e.g. p.B₁ vs p[3])\nLinear algebra operations can be performed on instances of the structs. This allows, for example, subtraction (without having to manually define methods) and that is useful for comparing parameter maps.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"parameters/tissueparameters.jl\"]","category":"page"},{"location":"api/#BlochSimulators.T₁T₂","page":"API","title":"BlochSimulators.T₁T₂","text":"T₁T₂{T} <: AbstractTissueParameters{2,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₀","page":"API","title":"BlochSimulators.T₁T₂B₀","text":"T₁T₂B₀{T} <: AbstractTissueParameters{2,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₀xy","page":"API","title":"BlochSimulators.T₁T₂B₀xy","text":"T₁T₂B₀xy{T} <: AbstractTissueParameters{5,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₀xyz","page":"API","title":"BlochSimulators.T₁T₂B₀xyz","text":"T₁T₂B₀xyz{T} <: AbstractTissueParameters{6,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₀ρˣρʸ","page":"API","title":"BlochSimulators.T₁T₂B₀ρˣρʸ","text":"T₁T₂B₀ρˣρʸ{T} <: AbstractTissueParameters{5,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₀ρˣρʸxy","page":"API","title":"BlochSimulators.T₁T₂B₀ρˣρʸxy","text":"T₁T₂B₀ρˣρʸxy{T} <: AbstractTissueParameters{7,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₀ρˣρʸxyz","page":"API","title":"BlochSimulators.T₁T₂B₀ρˣρʸxyz","text":"T₁T₂B₀ρˣρʸxyz{T} <: AbstractTissueParameters{8,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₁","page":"API","title":"BlochSimulators.T₁T₂B₁","text":"T₁T₂B₁{T} <: AbstractTissueParameters{3,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₁B₀","page":"API","title":"BlochSimulators.T₁T₂B₁B₀","text":"T₁T₂B₁B₀{T} <: AbstractTissueParameters{4,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₁B₀xy","page":"API","title":"BlochSimulators.T₁T₂B₁B₀xy","text":"T₁T₂B₁B₀xy{T} <: AbstractTissueParameters{6,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₁B₀xyz","page":"API","title":"BlochSimulators.T₁T₂B₁B₀xyz","text":"T₁T₂B₁B₀xyz{T} <: AbstractTissueParameters{7,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₁B₀ρˣρʸ","page":"API","title":"BlochSimulators.T₁T₂B₁B₀ρˣρʸ","text":"T₁T₂B₁B₀ρˣρʸ{T} <: AbstractTissueParameters{6,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₁B₀ρˣρʸxy","page":"API","title":"BlochSimulators.T₁T₂B₁B₀ρˣρʸxy","text":"T₁T₂B₁B₀ρˣρʸxy{T} <: AbstractTissueParameters{8,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₁B₀ρˣρʸxyz","page":"API","title":"BlochSimulators.T₁T₂B₁B₀ρˣρʸxyz","text":"T₁T₂B₁B₀ρˣρʸxyz{T} <: AbstractTissueParameters{9,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₁xy","page":"API","title":"BlochSimulators.T₁T₂B₁xy","text":"T₁T₂B₁xy{T} <: AbstractTissueParameters{5,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₁xyz","page":"API","title":"BlochSimulators.T₁T₂B₁xyz","text":"T₁T₂B₁xyz{T} <: AbstractTissueParameters{6,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₁ρˣρʸ","page":"API","title":"BlochSimulators.T₁T₂B₁ρˣρʸ","text":"T₁T₂B₁ρˣρʸ{T} <: AbstractTissueParameters{5,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₁ρˣρʸxy","page":"API","title":"BlochSimulators.T₁T₂B₁ρˣρʸxy","text":"T₁T₂B₁ρˣρʸxy{T} <: AbstractTissueParameters{7,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₁ρˣρʸxyz","page":"API","title":"BlochSimulators.T₁T₂B₁ρˣρʸxyz","text":"T₁T₂B₁ρˣρʸxyz{T} <: AbstractTissueParameters{8,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂xy","page":"API","title":"BlochSimulators.T₁T₂xy","text":"T₁T₂xy{T} <: AbstractTissueParameters{4,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂xyz","page":"API","title":"BlochSimulators.T₁T₂xyz","text":"T₁T₂xyz{T} <: AbstractTissueParameters{5,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂ρˣρʸ","page":"API","title":"BlochSimulators.T₁T₂ρˣρʸ","text":"T₁T₂ρˣρʸ{T} <: AbstractTissueParameters{4,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂ρˣρʸxy","page":"API","title":"BlochSimulators.T₁T₂ρˣρʸxy","text":"T₁T₂ρˣρʸxy{T} <: AbstractTissueParameters{6,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂ρˣρʸxyz","page":"API","title":"BlochSimulators.T₁T₂ρˣρʸxyz","text":"T₁T₂ρˣρʸxyz{T} <: AbstractTissueParameters{7,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#Sequences","page":"API","title":"Sequences","text":"","category":"section"},{"location":"api/#Abstract-Types","page":"API","title":"Abstract Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"BlochSimulator\nIsochromatSimulator\nEPGSimulator","category":"page"},{"location":"api/#BlochSimulators.BlochSimulator","page":"API","title":"BlochSimulators.BlochSimulator","text":"BlochSimulator{T}\n\nThe abstract type of which all sequence simulators will be a subtype. The parameter T should be a number type (e.g. Float64, Float32) and the tissueparameters that are used as input to the simulator should have the same number type. By convention, a BlochSimulator will be used to simulate magnetization at echo times only without taking into account spatial encoding gradients (i.e. readout or phase encoding gradients). To simulate the magnetization at other readout times, including phase from spatial encoding gradients, an AbstractTrajectory will be needed as well.\n\nTo make a simulator for a particular pulse sequence:\n\nMake a struct that's a subtype of either IsochromatSimulator or EPGSimulator.  The struct will hold parameters that are necessary for performing the simulations.\nAdd a method to simulate! that implements the pulse sequence. For both performance and GPU compatibility,  make sure that simulate! does not do any heap allocations. Examples for pSSFP and FISP  sequences are found in src/sequences.\nAdd methods to output_eltype and output_size that are used to allocate an output array within the simulate function.\n[Optional] Add a method to show for nicer printing of the sequence in the REPL\n[Optional] Add a method to getindex to easily reduce the length of the sequence\n[Optional] Add a constructor for the struct that takes in data from Matlab or  something else and assembles the struct\n\nIMPORTANT\n\nThe simulate! functions (which dispatch on the provided sequence) are assumed to be type-stable and non-allocating Should be possible to achieve when using functions from operators/epg.jlandoperators/isochromat.jl` and a properly parametrized sequence struct.\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.IsochromatSimulator","page":"API","title":"BlochSimulators.IsochromatSimulator","text":"IsochromatSimulator{T} <: BlochSimulator{T}\n\nAbstract type of which all sequence simulators that are based on the isochromat model will be a subtype. The parameter T should be a number type (e.g. Float64, Float32) and the tissueparameters that are used as input to the simulator should have the same number type.\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.EPGSimulator","page":"API","title":"BlochSimulators.EPGSimulator","text":"EPGSimulator{T,Ns} <: BlochSimulator{T}\n\nAbstract type of which all sequence simulators that are based on the EPG model will be a subtype. The parameter T should be a number type (e.g. Float64, Float32) and the tissueparameters that are used as input to the simulator should have the same number type. The parameter Ns corresponds to the maximum order of configuration states that are tracked in the simulations.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interface","page":"API","title":"Interface","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"sequences/_interface.jl\"]","category":"page"},{"location":"api/#BlochSimulators.output_dimensions-Tuple{BlochSimulator}","page":"API","title":"BlochSimulators.output_dimensions","text":"output_dimensions(::BlochSimulator)\n\nFor each <:BlochSimulator, a method should be added to this function that specifies the output size of the simulation for a single ::AbstractTissueParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.output_eltype-Tuple{BlochSimulator}","page":"API","title":"BlochSimulators.output_eltype","text":"output_eltype(::BlochSimulator)\n\nFor each <:BlochSimulator, a method should be added to this function that specifies the output type of the simulation. For MR signal simulation, this is typically a complex number representing the transverse magnetization. For other types of simulations, one may want to retrieve the x,y and z components of an isochromat as output (implemented as a FieldVector perhaps) or state configuration matrices Ω.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.simulate!-Tuple{Any, BlochSimulator, Any, AbstractTissueParameters}","page":"API","title":"BlochSimulators.simulate!","text":"simulate!(echos, sequence::BlochSimulator, state, p::AbstractTissueParameters) end\n\nFor each <:BlochSimulator, a method should be added to this function that implements the actual pulse sequence using information contained in the sequence struct together with the operators from src/operators/{isochromat,epg}.jl. For performance reasons as well as GPU compatibility it is important that the implementation is type-stable and non-allocating.\n\nArguments\n\nechos: Pre-allocated array with size(echos) = output_dimensions(sequence) and   eltype(echos) = output_eltype(sequence) to store the output of the simulation.\nsequence: Sequence struct containing fields that are used to implement the actual pulse   sequence.\nstate: Either an Isochromat or EPGStates, depending on which model is used.\np: Custom struct (<:AbstractTissueParameters) containing input parameters   to the simulation (e.g. T₁T₂)\n\n\n\n\n\n","category":"method"},{"location":"api/#Examples","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"sequences/fisp.jl\", \"sequences/generic2d.jl\", \"sequences/generic3d.jl\", \"sequences/pssfp.jl\"]","category":"page"},{"location":"api/#BlochSimulators.FISP","page":"API","title":"BlochSimulators.FISP","text":"FISP{T, Ns, U<:AbstractVector, V<:AbstractMatrix} <: EPGSimulator{T,Ns}\n\nThis struct is used to simulate gradient-spoiled sequence with varying flip angle scheme and adiabatic inversion prepulse using the EPG model. The TR and TE are fixed throughout the sequence. Slice profile correction is done using the partitioned EPG model, where for  each flip angle a vector of RF scaling factors are determined prior to the simulation (using, for example, the small tip-angle approximation or Shinnar LeRoux forward model).\n\nFields\n\nRF_train::U Vector with flip angle for each TR with abs.(RFtrain) the RF flip angles in degrees and   angle.(RFtrain) should be the RF phases in degrees.\nsliceprofiles::V # Matrix with RF scaling factors (a.u.) to simulate slice profile effects.    Each column represents the (flip angle dependent) scaling factors for one position along the slice direction.\nTR::T: Repetition time in seconds, assumed constant during the sequence\nTE::T: Echo time in seconds, assumed constant during the sequence\nmax_state::Val{Ns}: Maximum number of states to keep track of in EPG simulation\nTI::T: Inversion delay after the inversion prepulse in seconds\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.Generic2D","page":"API","title":"BlochSimulators.Generic2D","text":"Generic2D{T,V,M,S} where {T<:AbstractFloat, V<:AbstractVector, M<:AbstractMatrix, S} <: IsochromatSimulator{T}\n\nSimulate a generic 2D sequence defined by arrays containing RF and gradient waveforms. Contains a loop over z locations to take into account slice profile effects. The Δt vector stores the time intervals for the waveforms.\n\nFields\n\nRF::V{Complex{T}}: Vector with (complex) RF values during each time interval\nGR::M{T}: Matrix with GRx, GRy and GRz values during each time interval\nsample::S: Vector with Bool's to indicate the sample points\nΔt::V{T}: Vector with time intervals\nz::V{T}: Vector with different positions along the slice direction \n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.Generic3D","page":"API","title":"BlochSimulators.Generic3D","text":"Generic3D{T,V<:AbstractVector{Complex{T}},W<:AbstractVector{T},M<:AbstractMatrix{T},S} <: IsochromatSimulator{T}\n\nSimulate a generic sequence defined by arrays containing RF and gradient waveforms. Unlike the Generic2D sequence, it is assumed that the excitation is homogenous over the voxel and therefore no summation over a slice direction is applied. The Δt vector stores the time intervals for the waveforms.\n\nFields\n\nRF::V{Complex{T}}: Vector with (complex) RF values during each time interval\nGR::M{T}: Matrix with GRx, GRy and GRz values during each time interval\nsample::S: Vector with Bool's to indicate the sample points\nΔt::V{T}: Vector with time intervals\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.pSSFP","page":"API","title":"BlochSimulators.pSSFP","text":"pSSFP{T<:AbstractFloat,N,M,U<:AbstractVector{Complex{T}}} <: IsochromatSimulator{T}\n\nThis struct is used to simulate a balanced pSSFP sequence with varying flip angle scheme and adiabatic inversion prepulse based on isochromat model. The TR and TE are fixed throughout the sequence. Slice profile correction is done by discretizing the RF excitation waveform in time and using multiple Isochromats with different positions along the slice direction (z) per voxel. The sequence also uses an 'α/2' prepulse after the inversion.\n\nWithin each TR, multiple time steps are used to simulate the RF excitation. Then, in one time step we go from the end of the RF excitation to the echo time (applying slice refocussing gradient, T₂ decay and B₀ rotation), and again in one time step from the echo time to the start of the next RF excitation.\n\nFields\n\nRF_train::U Vector with flip angle for each TR with abs.(RFtrain) the RF flip angles in degrees and   angle.(RFtrain) should be the RF phases in degrees.\nTR::T: Repetition time in seconds, assumed constant during the sequence\nγΔtRF::SVector{N}{T}: Time-discretized RF waveform, normalized to flip angle of 1 degree\nΔt::NamedTuple{(:ex, :inv, :pr),NTuple{3,T}}: Time interval for each sample of excitation pulse (ex),   inversion delay (inv) and time between RF and TE (pr)\nγΔtGRz::NamedTuple{(:ex, :inv, :pr),NTuple{3,T}}: Slice select gradients for ex, inv and pr\nz::SVector{M}{T} # Vector with different positions along the slice direction.\n\n\n\n\n\n","category":"type"},{"location":"api/#Trajectories","page":"API","title":"Trajectories","text":"","category":"section"},{"location":"api/#Abstract-types","page":"API","title":"Abstract types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractTrajectory\nSpokesTrajectory","category":"page"},{"location":"api/#BlochSimulators.AbstractTrajectory","page":"API","title":"BlochSimulators.AbstractTrajectory","text":"AbstractTrajectory\n\nThe abstract type of which all gradient trajectories will be a subtype. The subtypes should contain fields that can describe the full trajectory during a sequence.\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.SpokesTrajectory","page":"API","title":"BlochSimulators.SpokesTrajectory","text":"SpokesTrajectory <: AbstractTrajectory\n\nTypical Cartesian and radial trajectories have a lot in common: a readout can be described by a starting point in k-space and a Δk per sample point. To avoid code repetition, both type of trajectories are made a subtype of SpokesTrajectory s.t. and some methods (that would be the same for both trajectories otherwise) are written for SpokesTrajectory instead.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interface-2","page":"API","title":"Interface","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"trajectories/_interface.jl\"]","category":"page"},{"location":"api/#BlochSimulators._get_readout_and_sample_idx-Tuple{Any, Any}","page":"API","title":"BlochSimulators._get_readout_and_sample_idx","text":"_get_readout_and_sample_idx(trajectory, t)\n\nGiven time index t, compute the associated readout and sample indices (r,s). For trajectories where each readout has the same length, this is equivalent to r,s = fld1(t,ns), mod1(t,ns) with ns being the (constant) number of samples per readout.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.expand_readout_and_sample!-Tuple{Any, Any, Any, BlochSimulators.AbstractTrajectory, Any, Any}","page":"API","title":"BlochSimulators.expand_readout_and_sample!","text":"expand_readout_and_sample!(output, readout_idx, m, trajectory::AbstractTrajectory, parameters, coil_sensitivities)\n\nFor each ::AbstractTrajectory, a method should be added to this function that, given the magnetization m at the readout with index readout_idx, it computes the magnetization at other readout points (applying spatial encoding gradients, T₂ decay, B₀ rotation, etc...) and stores it into output.\n\nArguments\n\noutput:         Pre-allocated output array (of typeof(coil_sensitivities)) in which the signal is stored.\nreadout_idx:    Index that corresponds to the current readout.\nm:              Magnetization at echo time for the current readout (without spatial encoding gradients applied).\ntrajectory:     Trajectory struct containing fields that are used to compute the magnetization at other readout times,                   including the effects of spatial encoding gradients.\nparameters:     Tissue parameters of current voxel, including spatial coordinates.\ncoil_sensitivities: Coil sensitivities in current voxel (stored as SVector).\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.nreadouts-Tuple{BlochSimulators.AbstractTrajectory}","page":"API","title":"BlochSimulators.nreadouts","text":"nreadouts(::AbstractTrajectory)\n\nFor each ::AbstractTrajectory, a method should be added to this function that specifies how many readouts the trajectory consists of.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.nsamples-Tuple{BlochSimulators.AbstractTrajectory}","page":"API","title":"BlochSimulators.nsamples","text":"nsamples(trajectory::AbstractTrajectory)\n\nDetermines the total number of samples acquired with the trajectory. Requires nreadouts and nsamplesperreadout to be implemented.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.nsamplesperreadout-Tuple{BlochSimulators.AbstractTrajectory, Any}","page":"API","title":"BlochSimulators.nsamplesperreadout","text":"nsamplesperreadout(::AbstractTrajectory, readout_idx)\n\nFor each ::AbstractTrajectory, a method should be added to this function that specifies how many samples in total are acquired during the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.to_sample_point-NTuple{5, Any}","page":"API","title":"BlochSimulators.to_sample_point","text":"to_sample_point(m, trajectory, readout_idx, sample_idx, parameters)\n\nFor each ::AbstractTrajectory, a method should be added to this function that, given the magnetization m at the readout with index readout_idx, it computes the magnetization at the readout point with index sample_idx (by applying spatial encoding gradients, T₂ decay, B₀ rotation, etc...) based on the trajectory and parameters.\n\nArguments\n\nm:              Magnetization at the echo with index readout_idx.\ntrajectory:     Trajectory struct containing fields that are used to compute the magnetization at other readout times,                   including the effects of spatial encoding gradients.\nreadout_idx:    Index that corresponds to the current readout.\nsample_idx:     Index for the desired sample during this readout.\nparameters:     Tissue parameters of current voxel, including spatial coordinates.\n\nOutput:\n\nmₛ:   Magnetization at sample with index sample_idx\n\n\n\n\n\n","category":"method"},{"location":"api/#Examples-2","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"trajectories/cartesian.jl\", \"trajectories/radial.jl\", \"trajectories/spiral.jl\"]","category":"page"},{"location":"api/#BlochSimulators.CartesianTrajectory","page":"API","title":"BlochSimulators.CartesianTrajectory","text":"CartesianTrajectory{T,I,J,U,V} <: SpokesTrajectory\n\nStruct that is used to implement a typical Cartesian gradient trajectory.  The trajectory is described in a compact fashion by only storing  the starting position in k-space (k_start_readout) for each readout  as well as the step in k-space per readout point Δk_adc.\n\nNote that CartesianTrajectory and RadialTrajectory are essentially the same in when using when using this compact description. A SpokesTrajectory struct is therefore defined as a supertype of both and methods are defined for SpokesTrajectory instead  to avoid code repetition.\n\nThe type parameters are intentionally left vague. The J, for example, may be an  integer for sequences where each readout has the same number of samples, but for  sequences with different numbers of samples per readout it may be a vector of integers.\n\nFields\n\nnreadouts::I: The total number of readouts for this trajectory\nnsamplesperreadout::J: The total number of samples per readout\nΔt::T: Time between sample points\nk_start_readout::U: Starting position in k-space for each readout\nΔk_adc::U: k-space step Δk between each readout\npy::V: Phase encoding index for each readout\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.kspace_coordinates-Tuple{SpokesTrajectory}","page":"API","title":"BlochSimulators.kspace_coordinates","text":"kspace_coordinates(tr::SpokesTrajectory)\n\nReturn matrix (nrsamplesperreadout, nrreadouts) with kspace coordinates for the trajectory. Needed for nuFFT reconstructions.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.sampling_mask-Tuple{CartesianTrajectory}","page":"API","title":"BlochSimulators.sampling_mask","text":"sampling_mask(tr::CartesianTrajectory)\n\nFor undersampled Cartesian trajectories, the gradient trajectory can also be described by a sampling mask.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.RadialTrajectory","page":"API","title":"BlochSimulators.RadialTrajectory","text":"RadialTrajectory{T,I,J,U,V} <: SpokesTrajectory\n\nStruct that is used to implement a typical radial gradient trajectory.  The trajectory can is described in a compact fashion by only storing  the starting position in k-space (k_start_readout) for each readout  as well as the step in k-space per readout point Δk_adc.\n\nNote that CartesianTrajectory and RadialTrajectory are essentially the same in when using when using this compact description. A SpokesTrajectory struct is therefore defined as a supertype of both and methods are defined for SpokesTrajectory instead  to avoid code repetition.\n\nThe type parameters are intentionally left vague. The J, for example, may be an  integer for sequences where each readout has the same number of samples, but for  sequences with different numbers of samples per readout it may be a vector of integers.\n\nFields\n\nnreadouts::I: The total number of readouts for this trajectory\nnsamplesperreadout::J: The total number of samples per readout\nΔt::T: Time between sample points\nk_start_readout::U: Starting position in k-space for each readout\nΔk_adc::U: k-space step Δk between each readout\nφ::V: Radial angle for each readout\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.add_gradient_delay!-Tuple{RadialTrajectory, Any}","page":"API","title":"BlochSimulators.add_gradient_delay!","text":"add_gradient_delay!(tr::RadialTrajectory, S)\n\nApply gradient delay to radial trajectory in in-place fashion. The delay is described by the 2x2 matrix S and is assumed to influence the start of the readout only, not the readout direction.\n\n\n\n\n\n","category":"method"},{"location":"api/#Dictionary-Simulation","page":"API","title":"Dictionary Simulation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"simulate(resource, sequence, parameters)","category":"page"},{"location":"api/#BlochSimulators.simulate-Tuple{Any, Any, Any}","page":"API","title":"BlochSimulators.simulate","text":"simulate(resource, sequence, parameters)\n\nSimulate the magnetization at echo times (without any spatial encoding gradients applied)  for all combinations of tissue parameters contained in parameters. \n\nUse this function to generate dictionaries for MR Fingerprinting purposes.\n\nArguments\n\nresource::ComputationalResource: Either CPU1(), CPUThreads(), CPUProcesses() or CUDALibs()\nsequence::BlochSimulator: Custom sequence struct\nparameters::AbstractVector{<:AbstractTissueParameters}: Vector with different combinations of tissue parameters\n\nReturns\n\ndictionary::AbstractArray: Array of size (output_dimensions(sequence), length(parameters)) containing the   magnetization at echo times for all combinations of input tissue parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"simulate/dictionary.jl\"]","category":"page"},{"location":"api/#BlochSimulators._allocate_output-Tuple{Any, BlochSimulator, Any}","page":"API","title":"BlochSimulators._allocate_output","text":"_allocate_output(resource, sequence::BlochSimulator, parameters)\n\nAllocate an array to store the output of the Bloch simulations (per voxel, echo times only) to be performed with the sequence. For each BlochSimulator, methods should have been added to output_eltype and output_dimensions for this function to work properly.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators._simulate!-Tuple{Any, ComputationalResources.CPU1, Any, Any}","page":"API","title":"BlochSimulators._simulate!","text":"_simulate!(output, ::CPU1, sequence, parameters)T\n\nRun Bloch simulations in a serial fashion on a single worker.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators._simulate!-Tuple{Any, ComputationalResources.CPUThreads, Any, Any}","page":"API","title":"BlochSimulators._simulate!","text":"_simulate!(output, ::CPUThreads, sequence, parameters)\n\nRun Bloch simulations in a multi-threaded fashion on a single worker.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators._simulate!-Tuple{Any, ComputationalResources.CUDALibs, Any, Any}","page":"API","title":"BlochSimulators._simulate!","text":"_simulate!(output, ::CUDALibs, sequence, parameters)\n\nRun Bloch simulations on a CUDA compatible GPU. Assumes output, sequence and parameters are already transferred to the GPU with the gpu function.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.cuda_simulate_kernel!-Tuple{Any, Any, Any}","page":"API","title":"BlochSimulators.cuda_simulate_kernel!","text":"cuda_simulate_kernel!(output, sequence, parameters)\n\nKernel function that gets launched by each thread on the GPU. Each thread performs Bloch simulations in a single voxel.\n\n\n\n\n\n","category":"method"},{"location":"api/#Signal-Simulation","page":"API","title":"Signal Simulation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"simulate(resource, sequence, parameters, trajectory, coil_sensitivities)","category":"page"},{"location":"api/#BlochSimulators.simulate-NTuple{5, Any}","page":"API","title":"BlochSimulators.simulate","text":"simulate(resource, sequence, parameters, trajectory, coil_sensitivities)\n\nSimulate the MR signal at timepoint t from coil i as: sᵢ(t) = ∑ⱼ cᵢⱼρⱼmⱼ(t), where cᵢⱼis the coil sensitivity of coil i at position of voxel j, ρⱼ is the proton density of voxel j and mⱼ(t) the (normalized) transverse magnetization in voxel j obtained through Bloch simulations.\n\nArguments\n\nresource::ComputationalResource: Either CPU1(), CPUThreads(), CPUProcesses() or CUDALibs()\nsequence::BlochSimulator: Custom sequence struct\nparameters::AbstractVector{<:AbstractTissueParameters}: Vector with tissue parameters for each voxel\ntrajectory::AbstractTrajectory: Custom trajectory struct\ncoil_sensitivities::AbstractVector{<:SVector{ncoils}}: Vector with ncoils coil sensitivities for each voxel\n\nReturns\n\nsignal::Vector{<:SVector{ncoils}}: Simulated MR signal for the sequence and trajectory. \n\nAt each timepoint, the signal for each of the ncoils is stored.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"simulate/signal.jl\"]","category":"page"},{"location":"api/#BlochSimulators._allocate_output-Tuple{Any, BlochSimulators.AbstractTrajectory, Any}","page":"API","title":"BlochSimulators._allocate_output","text":"_allocate_output(resource, trajectory::AbstractTrajectory, coil_sensitivities)\n\nAllocate an array to store the output of the Bloch simulations (all readout points, integrated over all voxels) to be performed with the sequence.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators._simulate!-Tuple{Any, ComputationalResources.CPU1, Any, Any, Any, Any}","page":"API","title":"BlochSimulators._simulate!","text":"_simulate(::CPU1, echos, parameters, trajectory, coil_sensitivities)\n\nPerform signal simulations on CPU. Outer loop over the number of voxels, inner loop over time.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators._simulate!-Tuple{Any, ComputationalResources.CUDALibs, Any, Any, Any, Any}","page":"API","title":"BlochSimulators._simulate!","text":"_simulate!(signal, ::CUDALibs, sequence, parameters, trajectory, coil_sensitivities)\n\nRun Bloch simulations on a CUDA compatible GPU. Assumes signal, sequence, parameters, trajectory and coil_sensitivities are already transferred to the GPU with the gpu function. Each thread gets assigned a time index and then it loops over the voxels.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.cuda_simulate_kernel!-NTuple{5, Any}","page":"API","title":"BlochSimulators.cuda_simulate_kernel!","text":"cuda_simulate_kernel!(output, sequence, parameters, trajectory, coil_sensitivities)\n\nKernel function that gets launched by each thread on the GPU. Each thread performs Bloch simulations in a single voxel.\n\n\n\n\n\n","category":"method"},{"location":"api/#Utility-Functions","page":"API","title":"Utility Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"utils/precision.jl\", \"utils/gpu.jl\"]","category":"page"},{"location":"api/#BlochSimulators.f32-Tuple{Any}","page":"API","title":"BlochSimulators.f32","text":"f32(x)\n\nChange precision of x to Float32. It uses Functors.fmap to recursively traverse the fields of the struct x. For custom structs (e.g. <:BlochSimulator or <:AbstractTrajectory), it is required that typeof(x) be made a Functors.@functor (e.g. @functor FISP).\n\nIt may be necessary to add new adapt rules (by adding new methods to adapt_storage) if new structs with complicated nested fields are introduced.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.f64-Tuple{Any}","page":"API","title":"BlochSimulators.f64","text":"f64(x)\n\nChange precision of x to Float64. It uses Functors.fmap to recursively traverse the fields of the struct x. For custom structs (e.g. <:BlochSimulator or <:AbstractTrajectory), it is required that typeof(x) be made a Functors.@functor (e.g. @functor FISP).\n\nIt may be necessary to add new adapt rules (by adding new methods to adapt_storage) if new structs with complicated nested fields are introduced.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.gpu-Tuple{Any}","page":"API","title":"BlochSimulators.gpu","text":"gpu(x)\n\nMove x to CUDA device. It uses Functors.fmap to recursively traverse the fields of the struct x, converting <:AbstractArrays to CuArrays, and ignoring isbitsarrays. For custom structs (e.g. <:BlochSimulator or <:AbstractTrajectory), it is required that typeof(x) be made a Functors.@functor (e.g. @functor FISP).\n\n\n\n\n\n","category":"method"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"dictionary/#MR-Fingerprinting-Dictionary-Generation","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"","category":"section"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"In this example we demonstrate how to generate an MR Fingerprinting dictionary using a FISP type sequence","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"using BlochSimulators\nusing ComputationalResources","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"First, construct a FISP sequence struct (see src/sequences/fisp.jl for which fields are necessary and which constructors exist)","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"nTR = 1000; # nr of TRs used in the simulation\nRF_train = LinRange(1,90,nTR) |> collect; # flip angle train\nTR,TE,TI = 0.010, 0.005, 0.100; # repetition time, echo time, inversion delay\nmax_state = 25; # maximum number of configuration states to keep track of\n\nsequence = FISP(RF_train, TR, TE, max_state, TI);","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"Next, set the desired input parameters","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"T₁ = 0.500:0.010:5.0; # T₁ range\nT₂ = 0.025:0.005:1.0; # T₂ range\n\nparameters = map(T₁T₂, Iterators.product(T₁,T₂)); # produce all parameter pairs\nparameters = filter(p -> (p.T₁ > p.T₂), parameters); # remove pairs with T₂ ≤ T₁","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"Now we can perform the simulations using different hardware resources","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"Note that the first time a function is called in a Julia session, a precompilation procedure starts and the runtime for subsequent function calls are significantly faster","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"First, we simply simulate a dictionary using single-threaded CPU mode:","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"@time dictionary = simulate(CPU1(), sequence, parameters);\n@time dictionary = simulate(CPU1(), sequence, parameters);","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"To use multiple threads, Julia must be started with the --threads=auto flag (or some integer instead of auto). Then, we can simulate in a multi-threaded fashion with the following syntax:","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"@time dictionary = simulate(CPUThreads(), sequence, parameters);\n@time dictionary = simulate(CPUThreads(), sequence, parameters);","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"For distributed CPU mode, use the Distribute packages (ships with Julia) to add workers first","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"using Distributed\naddprocs(4, exeflags=\"--project=.\")","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"Alternatively, if you can ssh into some other machine, you can add CPUs from that machine as follows:","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"addprocs([(\"12.345.67.89\", 4)], exeflags=\"--project=.\")","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"Or, if you want to run this code on cluster with a queuing system, use ClusterManagers package.","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"After workers have been added, load BlochSimulators on all workers and then start a distributed dictionary generation with:","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"@everywhere using BlochSimulators\n\n@time dictionary = simulate(CPUProcesses(), sequence, parameters);\n@time dictionary = simulate(CPUProcesses(), sequence, parameters);","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"To perform simulations on GPU, we first convert the sequence and parameters to single precision and then send them to the gpu","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"cu_sequence = sequence |> f32 |> gpu;\ncu_parameters = parameters |> f32 |> gpu;\n\n@time dictionary = simulate(CUDALibs(), cu_sequence, cu_parameters);\n@time dictionary = simulate(CUDALibs(), cu_sequence, cu_parameters);","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = BlochSimulators","category":"page"},{"location":"#BlochSimulators","page":"Home","title":"BlochSimulators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BlochSimulators is a Julia package for performing Bloch simulations within the context of Magnetic Resonance Imaging. It allows one to build custom sequence and trajectory structs to perform MR signal simulations on different computational resources, including CUDA compatible GPU cards. The development aim of package was to achieve the highest possible runtime performance. The package can be used to simulate dictionaries for MR Fingerprinting or to perform forward model evaluations for MR-STAT.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"At the moment, BlochSimulators is not registered in the General Julia registry. To install the package,  use either ","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/Oscar/BlochSimulators.jl ","category":"page"},{"location":"","page":"Home","title":"Home","text":"or ","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> dev https://github.com/Oscar/BlochSimulators.jl","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See CITATION.bib for details on how to cite this work.","category":"page"}]
}
