var documenterSearchIndex = {"docs":
[{"location":"signal/#Simulate-MR-Signal","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"","category":"section"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"using Pkg; Pkg.activate(\"docs\")","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"In this example we are going to generate a phantom and simulate the signal for a gradient-balanced sequence with a Cartesian gradient trajectory","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"# stuf\nusing Revise\nusing BlochSimulators\nusing ComputationalResources\nusing StaticArrays\nusing LinearAlgebra","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"using PyPlot","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"using FFTW\nimport ImagePhantoms","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"First we assemble a Shepp Logan phantom with homogeneous T₁ and T₂ but non-constant proton density and B₀","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"N = 256\nρ = complex.(ImagePhantoms.shepp_logan(N, ImagePhantoms.SheppLoganEmis())');\nT₁ = fill(0.85, N, N);\nT₂ = fill(0.05, N, N);\nB₀ = repeat(1:N,1,N);","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"We also set the spatial coordinates for the phantom","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"FOVˣ, FOVʸ = 25.6, 25.6;\nX = [x for x ∈ LinRange(-FOVˣ/2, FOVˣ/2, N), y ∈ 1:N];\nY = [y for x ∈ 1:N, y ∈ LinRange(-FOVʸ/2, FOVʸ/2, N)];","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"Finally we assemble the phantom as an array of T₁T₂B₀ρˣρʸxy values","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"parameters = map(T₁T₂B₀ρˣρʸxy, T₁, T₂, B₀, real.(ρ), imag.(ρ), X, Y);","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"Next, we assemble a balanced sequence with constant flip angle of 60 degrees, a TR of 10 ms and 0-π phase cycling. See src/sequences/pssfp.jl for the sequence description and the fields for which values must be provided","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"nTR = 5N\nRF_train = complex.(fill(90.0, nTR)) # constant flip angle train\nRF_train[2:2:end] .*= -1 # 0-π phase cycling\nnRF = 25 # nr of RF discretization points\ndurRF = 0.001 # duration of RF excitation\nTR = 0.010 # repetition time\nTI = 20.0 # long inversion delay -> no inversion\ngaussian = [exp(-(i-(nRF/2))^2 * inv(nRF)) for i ∈ 1:nRF] # RF excitation waveform\nγΔtRF = (π/180) * normalize(gaussian, 1) |> SVector{nRF} # normalize to flip angle of 1 degree\nΔt = (ex=durRF/nRF, inv = TI, pr = (TR - durRF)/2); # time intervals during TR\nγΔtGRz = (ex=0.002/nRF, inv = 0.00, pr = -0.01); # slice select gradient strengths during TR\nnz = 35 # nr of spins in z direction\nz = SVector{nz}(LinRange(-1,1,nz)) # z locations\n\nsequence = pSSFP(RF_train, TR, γΔtRF, Δt, γΔtGRz, z)","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"Next, we assemble a Cartesian trajectory with linear phase encoding (see src/trajectories/cartesian.jl).","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"nr = 5N # nr of readouts\nns = N # nr of samples per readout\nΔt_adc = 10^-5 # time between sample points\npy = -(N÷2):1:(N÷2)-1 # phase encoding indices\npy = repeat(py, nr÷N)\nΔkˣ = 2π / FOVˣ; # k-space step in x direction for Nyquist sampling\nΔkʸ = 2π / FOVʸ; # k-space step in y direction for Nyquist sampling\nk0 = [(-ns/2 * Δkˣ) + im * (py[r] * Δkʸ) for r in 1:nr]; # starting points in k-space per readout\n\ntrajectory = CartesianTrajectory(nr,ns,Δt_adc,k0,Δkˣ,py);","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"We use two different receive coils","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"coil₁ = complex.(repeat(LinRange(0.5,1.0,N),1,N));\ncoil₂ = coil₁';\n\ncoil_sensitivities = map(SVector{2}, vec(coil₁), vec(coil₂))","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"Now simulate the signal for the sequence, trajectory, phantom and coils on GPU","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"resource = CUDALibs()\n\nsequence            = gpu(f32(sequence))\nparameters          = gpu(f32(parameters))\ntrajectory          = gpu(f32(trajectory))\ncoil_sensitivities  = gpu(f32(coil_sensitivities))\n\nusing BlochSimulators.CUDA\n\nresource = CUDALibs()","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"compute magnetization at echo times in all voxels","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"CUDA.@time echos = simulate_echos(resource, sequence, parameters);","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"apply phase encoding (typically only for Cartesian trajectories)","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"CUDA.@time phase_encoding!(echos, trajectory, parameters)","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"compute signal from (phase-encoded) magnetization at echo times","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"CUDA.@time signal = echos_to_signal(resource, echos, parameters, trajectory, coil_sensitivities);\n\nsignal = collect(signal)","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"Let's look at fft images of the signals from the two different coils","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"signal₁ = first.(signal)\nsignal₂ = last.(signal)\n\n\n@. signal₁[2:2:end] *= -1 # correct for phase cycling\n@. signal₂[2:2:end] *= -1 # correct for phase cycling\n\nfft_image₁ = rot180(ifft(reshape(signal₁,N,N))) # rot180 instead of fftshifts\nfft_image₂ = rot180(ifft(reshape(signal₂,N,N))) # rot180 instead of fftshifts\n\nfigure()\nsubplot(1,3,1); imshow(abs.(ρ)); title(\"Ground truth \\n proton density\")\nsubplot(1,3,2); imshow(abs.(fft_image₁)); title(\"fft-image coil 1\")\nsubplot(1,3,3); imshow(abs.(fft_image₂)); title(\"fft-image coil 2\")","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"Note the banding due to off-resonance","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"","category":"page"},{"location":"signal/","page":"Simulate MR Signal","title":"Simulate MR Signal","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = BlochSimulators","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Isochromat-Operators","page":"API","title":"Isochromat Operators","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Isochromat","category":"page"},{"location":"api/#BlochSimulators.Isochromat","page":"API","title":"BlochSimulators.Isochromat","text":"struct Isochromat{T<:Real} <: FieldVector{3,T}\n    x::T\n    y::T\n    z::T\nend\n\nHolds the x,y,z components of a spin isochromat in a FieldVector, which is a StaticVector (from the package StaticArrays) with custom fieldnames.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"operators/isochromat.jl\"]","category":"page"},{"location":"api/#BlochSimulators.decay-Union{Tuple{T}, Tuple{Isochromat{T}, Any, Any}} where T","page":"API","title":"BlochSimulators.decay","text":"decay(m::Isochromat{T}, E₁, E₂) where T\n\nApply T₂ decay to transverse component and T₁ decay to longitudinal component of Isochromat.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.initialize_states-Union{Tuple{T}, Tuple{ComputationalResources.AbstractResource, IsochromatSimulator{T}}} where T","page":"API","title":"BlochSimulators.initialize_states","text":"initialize_states(::AbstractResource, ::IsochromatSimulator{T}) where T\n\nInitialize a spin isochromat to be used throughout a simulation of the sequence.\n\nThis may seem redundant but to is necessary to share the same programming interface with EPGSimulators.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.invert-Union{Tuple{Isochromat{T}}, Tuple{T}} where T","page":"API","title":"BlochSimulators.invert","text":"invert(m::Isochromat{T}, p::AbstractTissueParameters) where T\n\nInvert Isochromat with B₁ insenstive (i.e. adiabatic) inversion pulse\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.invert-Union{Tuple{T}, Tuple{Isochromat{T}, AbstractTissueParameters}} where T","page":"API","title":"BlochSimulators.invert","text":"invert(m::Isochromat{T}, p::AbstractTissueParameters) where T\n\nInvert z-component of Isochromat (assuming spoiled transverse magnetization so xy-component zero).\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.regrowth-Union{Tuple{T}, Tuple{Isochromat{T}, Any}} where T","page":"API","title":"BlochSimulators.regrowth","text":"regrowth(m::Isochromat{T}, E₁) where T\n\nApply T₁ regrowth to longitudinal component of Isochromat.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.rotate-Tuple{Isochromat, Any, Any, Any, AbstractTissueParameters}","page":"API","title":"BlochSimulators.rotate","text":"rotate(m::Isochromat, γΔtGRz, z, Δt, p::AbstractTissueParameters)\n\nRotation of Isochromat without RF (so around z-axis only) due to gradients and B0 (i.e. refocussing slice select gradient).\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.rotate-Union{Tuple{T}, Tuple{Isochromat{T}, Any, Any, Any, Any, AbstractTissueParameters}} where T","page":"API","title":"BlochSimulators.rotate","text":"rotate(m::Isochromat{T}, γΔtRF::Complex, γΔtGR::Tuple, (x,y,z), Δt, p::AbstractTissueParameters) where T\n\nRF, gradient and/or ΔB₀ induced rotation of Isochromat computed using Rodrigues rotation formula (https://en.wikipedia.org/wiki/Rodrigues%27rotationformula).\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.sample_transverse!-Tuple{Any, Union{Integer, CartesianIndex}, Isochromat}","page":"API","title":"BlochSimulators.sample_transverse!","text":"sample!(output, index::Union{Integer,CartesianIndex}, m::Isochromat)\n\nSample transverse magnetization from Isochromat. The \"+=\" is needed for 2D sequences where slice profile is taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.sample_xyz!-Union{Tuple{S}, Tuple{AbstractArray{<:S}, Union{Integer, CartesianIndex}, Isochromat}} where S","page":"API","title":"BlochSimulators.sample_xyz!","text":"sample_xyz!(output, index::Union{Integer,CartesianIndex}, m::Isochromat)\n\nSample m.x, m.y and m.z components from Isochromat. The \"+=\" is needed for 2D sequences where slice profile is taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api/#EPG-Operators","page":"API","title":"EPG Operators","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"EPGStates","category":"page"},{"location":"api/#BlochSimulators.EPGStates","page":"API","title":"BlochSimulators.EPGStates","text":"EPGStates = Union{MMatrix{3}, SizedMatrix{3}}\n\nIn the EPG model, the configuration state matrix Ω will be updated inplace. On CPU, we use StaticArrays.MMatrix. The MMatrix will not escape _simulate! and therefore should not result in allocations. On GPU, we use shared memory (CUDA.CuStaticSharedArray). The shared memory is allocated for all threads within a block simultaneously. We then take a @view and wrap it in a SizedArray. Without the SizedArray, the type would be long and unreadable. By wrapping, we can then simply dispatch on a SizedArray instead.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"operators/epg.jl\"]","category":"page"},{"location":"api/#BlochSimulators.F̄₋-Tuple{Any}","page":"API","title":"BlochSimulators.F̄₋","text":"F̄₋(Ω)\n\nView into the second row of the configuration state matrix Ω, corresponding to the F̄₋ states.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.F₊-Tuple{Any}","page":"API","title":"BlochSimulators.F₊","text":"F₊(Ω)\n\nView into the first row of the configuration state matrix Ω, corresponding to the F₊ states.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.Z-Tuple{Any}","page":"API","title":"BlochSimulators.Z","text":"Z(Ω)\n\nView into the third row of the configuration state matrix Ω, corresponding to the Z states.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.decay!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData<:AbstractArray{T, M}}}, Any, Any}","page":"API","title":"BlochSimulators.decay!","text":"decay!(Ω::EPGStates, E₁, E₂)\n\nT₂ decay for F-components, T₁ decay for Z-component of each state.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.dephasing!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData<:AbstractArray{T, M}}}}","page":"API","title":"BlochSimulators.dephasing!","text":"dephasing!(Ω::EPGStates)\n\nShift states around due to dephasing gradient: The F₊ go up one, the F̄₋ go down one and Z do not change\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.excite!-Union{Tuple{T}, Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData<:AbstractArray{T, M}}}, T, AbstractTissueParameters}} where T<:Union{Complex, Unitful.Quantity{<:Complex}}","page":"API","title":"BlochSimulators.excite!","text":"excite!(Ω::EPGStates, RF::Complex, p::AbstractTissueParameters)\n\nMixing of states due to RF pulse. Magnitude of RF is the flip angle in degrees. Phase of RF is the phase of the pulse. If RF is real, the computations simplify a little bit.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.excite!-Union{Tuple{T}, Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData<:AbstractArray{T, M}}}, T, AbstractTissueParameters}} where T<:Union{Real, Unitful.Quantity{<:Real}}","page":"API","title":"BlochSimulators.excite!","text":"excite!(Ω::EPGStates, RF::T, p::AbstractTissueParameters) where T<:Union{Real, Quantity{<:Real}}\n\nIf RF is real, the calculations simplify (and probably Ω is real too, reducing memory (access) requirements).\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.initial_conditions!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData<:AbstractArray{T, M}}}}","page":"API","title":"BlochSimulators.initial_conditions!","text":"initial_conditions!(Ω::EPGStates)\n\nSet all components of all states to 0, except the Z-component of the 0th state which is set to 1.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.initialize_states-Union{Tuple{Ns}, Tuple{T}, Tuple{ComputationalResources.AbstractResource, EPGSimulator{T, Ns}}} where {T, Ns}","page":"API","title":"BlochSimulators.initialize_states","text":"initialize_states(::AbstractResource, sequence::EPGSimulator{T,Ns}) where {T,Ns}\n\nInitialize an MMatrix of EPG states on CPU to be used throughout the simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.initialize_states-Union{Tuple{Ns}, Tuple{T}, Tuple{ComputationalResources.CUDALibs, EPGSimulator{T, Ns}}} where {T, Ns}","page":"API","title":"BlochSimulators.initialize_states","text":"initialize_states(::CUDALibs, sequence::EPGSimulator{T,Ns}) where {T,Ns}\n\nInitialize an array of EPG states on a CUDA GPU to be used throughout the simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.invert!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData<:AbstractArray{T, M}}}, AbstractTissueParameters}","page":"API","title":"BlochSimulators.invert!","text":"invert!(Ω::EPGStates, p::AbstractTissueParameters)\n\nInvert Z-component of states of all orders. Assumes fully spoiled transverse magnetization.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.invert!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData<:AbstractArray{T, M}}}}","page":"API","title":"BlochSimulators.invert!","text":"invert!(Ω::EPGStates)\n\nInvert with B₁ insenstive (i.e. adiabatic) inversion pulse\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.regrowth!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData<:AbstractArray{T, M}}}, Any}","page":"API","title":"BlochSimulators.regrowth!","text":"regrowth!(Ω::EPGStates, E₁)\n\nT₁ regrowth for Z-component of 0th order state.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.rotate!-Union{Tuple{T}, Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData<:AbstractArray{T, M}}}, T}} where T","page":"API","title":"BlochSimulators.rotate!","text":"rotate!(Ω::EPGStates, eⁱᶿ::T) where T\n\nRotate F₊ and F̄₋ states under the influence of eⁱᶿ = exp(i * ΔB₀ * Δt)\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.rotate_decay!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData<:AbstractArray{T, M}}}, Any, Any, Any}","page":"API","title":"BlochSimulators.rotate_decay!","text":"rotate_decay!(Ω::EPGStates, E₁, E₂, eⁱᶿ)\n\nRotate and decay combined\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.sample_transverse!-Tuple{Any, Union{Integer, CartesianIndex}, Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData<:AbstractArray{T, M}}}}","page":"API","title":"BlochSimulators.sample_transverse!","text":"sample_transverse!(output, index::Union{Integer,CartesianIndex}, Ω::EPGStates)\n\nSample the measurable transverse magnetization, that is, the F₊ component of the 0th state. The += is needed for 2D sequences where slice profile is taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.sample_Ω!-Tuple{Any, Union{Integer, CartesianIndex}, Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData<:AbstractArray{T, M}}}}","page":"API","title":"BlochSimulators.sample_Ω!","text":"sample_Ω!(output, index::Union{Integer,CartesianIndex}, Ω::EPGStates)\n\nSample the entire configuration state matrix Ω. The += is needed for 2D sequences where slice profile is taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.spoil!-Tuple{Union{StaticArraysCore.MMatrix{3}, StaticArraysCore.SizedMatrix{3, S2, T, M, TData} where {S2, T, M, TData<:AbstractArray{T, M}}}}","page":"API","title":"BlochSimulators.spoil!","text":"spoil!(Ω::EPGStates)\n\nPerfectly spoil the transverse components of all states.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.Ω_eltype-Union{Tuple{EPGSimulator{T, Ns}}, Tuple{Ns}, Tuple{T}} where {T, Ns}","page":"API","title":"BlochSimulators.Ω_eltype","text":"Ω_eltype(sequence::EPGSimulator{T,Ns}) where {T,Ns} = Complex{T}\n\nBy default, configuration states are complex. For some sequences, they will only ever be real (no RF phase, no complex slice profile correction) and for these sequences a method needs to be added to this function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tissue-Parameters","page":"API","title":"Tissue Parameters","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractTissueParameters","category":"page"},{"location":"api/#BlochSimulators.AbstractTissueParameters","page":"API","title":"BlochSimulators.AbstractTissueParameters","text":"AbstractTissueParameters{N,T} <: FieldVector{N,T}\n\nAbstract type for structs that hold different combinations of tissue parameters.\n\nPossible fields\n\nT₁::T: T₁ relaxation parameters of a voxel\nT₂::T: T₂ relaxation parameters of a voxel\nB₁::T: Scaling factor for effective B₁ excitation field within a voxel\nB₀::T: Off-resonance with respect to main magnetic field within a voxel\nρˣ::T: Real part of proton density within a voxel\nρʸ::T: Imaginary part of proton density within a voxel\nx::T: Position of voxel along the x direction\ny::T: Position of voxel along the y direction\nz::T: Position of voxel along the z direction\n\nThe structs are subtypes of FieldVector, which is a StaticVector with named fields (see the documentation of StaticArrays.jl). There are three reasons for letting the structs be subtypes of FieldVector:\n\nFieldVectors/StaticVectors have sizes that are known at compile time. This is beneficial for performance reasons\nThe named fields improve readability of the code (e.g. p.B₁ vs p[3])\nLinear algebra operations can be performed on instances of the structs. This allows, for example, subtraction (without having to manually define methods) and that is useful for comparing parameter maps.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"parameters/tissueparameters.jl\"]","category":"page"},{"location":"api/#BlochSimulators.T₁T₂","page":"API","title":"BlochSimulators.T₁T₂","text":"T₁T₂{T} <: AbstractTissueParameters{2,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₀","page":"API","title":"BlochSimulators.T₁T₂B₀","text":"T₁T₂B₀{T} <: AbstractTissueParameters{2,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₀xy","page":"API","title":"BlochSimulators.T₁T₂B₀xy","text":"T₁T₂B₀xy{T} <: AbstractTissueParameters{5,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₀xyz","page":"API","title":"BlochSimulators.T₁T₂B₀xyz","text":"T₁T₂B₀xyz{T} <: AbstractTissueParameters{6,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₀ρˣρʸ","page":"API","title":"BlochSimulators.T₁T₂B₀ρˣρʸ","text":"T₁T₂B₀ρˣρʸ{T} <: AbstractTissueParameters{5,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₀ρˣρʸxy","page":"API","title":"BlochSimulators.T₁T₂B₀ρˣρʸxy","text":"T₁T₂B₀ρˣρʸxy{T} <: AbstractTissueParameters{7,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₀ρˣρʸxyz","page":"API","title":"BlochSimulators.T₁T₂B₀ρˣρʸxyz","text":"T₁T₂B₀ρˣρʸxyz{T} <: AbstractTissueParameters{8,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₁","page":"API","title":"BlochSimulators.T₁T₂B₁","text":"T₁T₂B₁{T} <: AbstractTissueParameters{3,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₁B₀","page":"API","title":"BlochSimulators.T₁T₂B₁B₀","text":"T₁T₂B₁B₀{T} <: AbstractTissueParameters{4,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₁B₀xy","page":"API","title":"BlochSimulators.T₁T₂B₁B₀xy","text":"T₁T₂B₁B₀xy{T} <: AbstractTissueParameters{6,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₁B₀xyz","page":"API","title":"BlochSimulators.T₁T₂B₁B₀xyz","text":"T₁T₂B₁B₀xyz{T} <: AbstractTissueParameters{7,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₁B₀ρˣρʸ","page":"API","title":"BlochSimulators.T₁T₂B₁B₀ρˣρʸ","text":"T₁T₂B₁B₀ρˣρʸ{T} <: AbstractTissueParameters{6,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₁B₀ρˣρʸxy","page":"API","title":"BlochSimulators.T₁T₂B₁B₀ρˣρʸxy","text":"T₁T₂B₁B₀ρˣρʸxy{T} <: AbstractTissueParameters{8,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₁B₀ρˣρʸxyz","page":"API","title":"BlochSimulators.T₁T₂B₁B₀ρˣρʸxyz","text":"T₁T₂B₁B₀ρˣρʸxyz{T} <: AbstractTissueParameters{9,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₁xy","page":"API","title":"BlochSimulators.T₁T₂B₁xy","text":"T₁T₂B₁xy{T} <: AbstractTissueParameters{5,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₁xyz","page":"API","title":"BlochSimulators.T₁T₂B₁xyz","text":"T₁T₂B₁xyz{T} <: AbstractTissueParameters{6,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₁ρˣρʸ","page":"API","title":"BlochSimulators.T₁T₂B₁ρˣρʸ","text":"T₁T₂B₁ρˣρʸ{T} <: AbstractTissueParameters{5,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₁ρˣρʸxy","page":"API","title":"BlochSimulators.T₁T₂B₁ρˣρʸxy","text":"T₁T₂B₁ρˣρʸxy{T} <: AbstractTissueParameters{7,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂B₁ρˣρʸxyz","page":"API","title":"BlochSimulators.T₁T₂B₁ρˣρʸxyz","text":"T₁T₂B₁ρˣρʸxyz{T} <: AbstractTissueParameters{8,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂xy","page":"API","title":"BlochSimulators.T₁T₂xy","text":"T₁T₂xy{T} <: AbstractTissueParameters{4,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂xyz","page":"API","title":"BlochSimulators.T₁T₂xyz","text":"T₁T₂xyz{T} <: AbstractTissueParameters{5,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂ρˣρʸ","page":"API","title":"BlochSimulators.T₁T₂ρˣρʸ","text":"T₁T₂ρˣρʸ{T} <: AbstractTissueParameters{4,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂ρˣρʸxy","page":"API","title":"BlochSimulators.T₁T₂ρˣρʸxy","text":"T₁T₂ρˣρʸxy{T} <: AbstractTissueParameters{6,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.T₁T₂ρˣρʸxyz","page":"API","title":"BlochSimulators.T₁T₂ρˣρʸxyz","text":"T₁T₂ρˣρʸxyz{T} <: AbstractTissueParameters{7,T}\n\n\n\n\n\n","category":"type"},{"location":"api/#Sequences","page":"API","title":"Sequences","text":"","category":"section"},{"location":"api/#Abstract-Types","page":"API","title":"Abstract Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"BlochSimulator\nIsochromatSimulator\nEPGSimulator","category":"page"},{"location":"api/#BlochSimulators.BlochSimulator","page":"API","title":"BlochSimulators.BlochSimulator","text":"BlochSimulator{T}\n\nThe abstract type of which all sequence simulators will be a subtype. The parameter T should be a number type (e.g. Float64, Float32) and the tissueparameters that are used as input to the simulator should have the same number type. By convention, a BlochSimulator will be used to simulate magnetization at echo times only without taking into account spatial encoding gradients (i.e. readout or phase encoding gradients). To simulate the magnetization at other readout times, including phase from spatial encoding gradients, an AbstractTrajectory will be needed as well.\n\nTo make a simulator for a particular pulse sequence:\n\nMake a struct that's a subtype of either IsochromatSimulator or EPGSimulator.  The struct will hold parameters that are necessary for performing the simulations.\nAdd a method to simulate_echos! that implements the pulse sequence. For both performance and GPU compatibility,  make sure that simulate_echos! does not do any heap allocations. Examples for pSSFP and FISP  sequences are found in src/sequences.\nAdd methods to output_eltype and output_size that are used to allocate an output array within the simulate function.\n[Optional] Add a method to show for nicer printing of the sequence in the REPL\n[Optional] Add a method to getindex to easily reduce the length of the sequence\n[Optional] Add a constructor for the struct that takes in data from Matlab or  something else and assembles the struct\n\nIMPORTANT\n\nThe simulate_echos! functions (which dispatch on the provided sequence) are assumed to be type-stable and non-allocating Should be possible to achieve when using functions from operators/epg.jlandoperators/isochromat.jl` and a properly parametrized sequence struct.\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.IsochromatSimulator","page":"API","title":"BlochSimulators.IsochromatSimulator","text":"IsochromatSimulator{T} <: BlochSimulator{T}\n\nAbstract type of which all sequence simulators that are based on the isochromat model will be a subtype. The parameter T should be a number type (e.g. Float64, Float32) and the tissueparameters that are used as input to the simulator should have the same number type.\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.EPGSimulator","page":"API","title":"BlochSimulators.EPGSimulator","text":"EPGSimulator{T,Ns} <: BlochSimulator{T}\n\nAbstract type of which all sequence simulators that are based on the EPG model will be a subtype. The parameter T should be a number type (e.g. Float64, Float32) and the tissueparameters that are used as input to the simulator should have the same number type. The parameter Ns corresponds to the maximum order of configuration states that are tracked in the simulations.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interface","page":"API","title":"Interface","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"sequences/_interface.jl\"]","category":"page"},{"location":"api/#BlochSimulators.output_dimensions-Tuple{BlochSimulator}","page":"API","title":"BlochSimulators.output_dimensions","text":"output_dimensions(::BlochSimulator)\n\nFor each <:BlochSimulator, a method should be added to this function that specifies the output size of the simulation for a single ::AbstractTissueParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.output_eltype-Tuple{BlochSimulator}","page":"API","title":"BlochSimulators.output_eltype","text":"output_eltype(::BlochSimulator)\n\nFor each <:BlochSimulator, a method should be added to this function that specifies the output type of the simulation. For MR signal simulation, this is typically a complex number representing the transverse magnetization. For other types of simulations, one may want to retrieve the x,y and z components of an isochromat as output (implemented as a FieldVector perhaps) or state configuration matrices Ω.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.simulate_echos!-Tuple{Any, BlochSimulator, Any, AbstractTissueParameters}","page":"API","title":"BlochSimulators.simulate_echos!","text":"simulate_echos!(echos, sequence::BlochSimulator, state, p::AbstractTissueParameters) end\n\nFor each <:BlochSimulator, a method should be added to this function that implements the actual pulse sequence using information contained in the sequence struct together with the operators from src/operators/{isochromat,epg}.jl. For performance reasons as well as GPU compatibility it is important that the implementation is type-stable and non-allocating.\n\nArguments\n\nechos: Pre-allocated array with size(echos) = output_dimensions(sequence) and   eltype(echos) = output_eltype(sequence) to store the output of the simulation.\nsequence: Sequence struct containing fields that are used to implement the actual pulse   sequence.\nstate: Either an Isochromat or EPGStates, depending on which model is used.\np: Custom struct (<:AbstractTissueParameters) containing input parameters   to the simulation (e.g. T₁T₂)\n\n\n\n\n\n","category":"method"},{"location":"api/#Examples","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"sequences/fisp.jl\", \"sequences/generic2d.jl\", \"sequences/generic3d.jl\", \"sequences/pssfp.jl\"]","category":"page"},{"location":"api/#BlochSimulators.FISP","page":"API","title":"BlochSimulators.FISP","text":"FISP{T, Ns, U<:AbstractVector, V<:AbstractMatrix} <: EPGSimulator{T,Ns}\n\nThis struct is used to simulate gradient-spoiled sequence with varying flip angle scheme and adiabatic inversion prepulse using the EPG model. The TR and TE are fixed throughout the sequence. Slice profile correction is done using the partitioned EPG model, where for  each flip angle a vector of RF scaling factors are determined prior to the simulation (using, for example, the small tip-angle approximation or Shinnar LeRoux forward model).\n\nFields\n\nRF_train::U Vector with flip angle for each TR with abs.(RFtrain) the RF flip angles in degrees and   angle.(RFtrain) should be the RF phases in degrees.\nsliceprofiles::V # Matrix with RF scaling factors (a.u.) to simulate slice profile effects.    Each column represents the (flip angle dependent) scaling factors for one position along the slice direction.\nTR::T: Repetition time in seconds, assumed constant during the sequence\nTE::T: Echo time in seconds, assumed constant during the sequence\nmax_state::Val{Ns}: Maximum number of states to keep track of in EPG simulation\nTI::T: Inversion delay after the inversion prepulse in seconds\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.Generic2D","page":"API","title":"BlochSimulators.Generic2D","text":"Generic2D{T,V,M,S} where {T<:AbstractFloat, V<:AbstractVector, M<:AbstractMatrix, S} <: IsochromatSimulator{T}\n\nSimulate a generic 2D sequence defined by arrays containing RF and gradient waveforms. Contains a loop over z locations to take into account slice profile effects. The Δt vector stores the time intervals for the waveforms.\n\nFields\n\nRF::V{Complex{T}}: Vector with (complex) RF values during each time interval\nGR::M{T}: Matrix with GRx, GRy and GRz values during each time interval\nsample::S: Vector with Bool's to indicate the sample points\nΔt::V{T}: Vector with time intervals\nz::V{T}: Vector with different positions along the slice direction \n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.Generic3D","page":"API","title":"BlochSimulators.Generic3D","text":"Generic3D{T,V<:AbstractVector{Complex{T}},W<:AbstractVector{T},M<:AbstractMatrix{T},S} <: IsochromatSimulator{T}\n\nSimulate a generic sequence defined by arrays containing RF and gradient waveforms. Unlike the Generic2D sequence, it is assumed that the excitation is homogenous over the voxel and therefore no summation over a slice direction is applied. The Δt vector stores the time intervals for the waveforms.\n\nFields\n\nRF::V{Complex{T}}: Vector with (complex) RF values during each time interval\nGR::M{T}: Matrix with GRx, GRy and GRz values during each time interval\nsample::S: Vector with Bool's to indicate the sample points\nΔt::V{T}: Vector with time intervals\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.pSSFP","page":"API","title":"BlochSimulators.pSSFP","text":"pSSFP{T<:AbstractFloat,N,M,U<:AbstractVector{Complex{T}}} <: IsochromatSimulator{T}\n\nThis struct is used to simulate a balanced pSSFP sequence with varying flip angle scheme and adiabatic inversion prepulse based on isochromat model. The TR and TE are fixed throughout the sequence. Slice profile correction is done by discretizing the RF excitation waveform in time and using multiple Isochromats with different positions along the slice direction (z) per voxel. The sequence also uses an 'α/2' prepulse after the inversion.\n\nWithin each TR, multiple time steps are used to simulate the RF excitation. Then, in one time step we go from the end of the RF excitation to the echo time (applying slice refocussing gradient, T₂ decay and B₀ rotation), and again in one time step from the echo time to the start of the next RF excitation.\n\nFields\n\nRF_train::U Vector with flip angle for each TR with abs.(RFtrain) the RF flip angles in degrees and   angle.(RFtrain) should be the RF phases in degrees.\nTR::T: Repetition time in seconds, assumed constant during the sequence\nγΔtRF::SVector{N}{T}: Time-discretized RF waveform, normalized to flip angle of 1 degree\nΔt::NamedTuple{(:ex, :inv, :pr),NTuple{3,T}}: Time interval for each sample of excitation pulse (ex),   inversion delay (inv) and time between RF and TE (pr)\nγΔtGRz::NamedTuple{(:ex, :inv, :pr),NTuple{3,T}}: Slice select gradients for ex, inv and pr\nz::SVector{M}{T} # Vector with different positions along the slice direction.\n\n\n\n\n\n","category":"type"},{"location":"api/#Trajectories","page":"API","title":"Trajectories","text":"","category":"section"},{"location":"api/#Abstract-types","page":"API","title":"Abstract types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractTrajectory\nSpokesTrajectory","category":"page"},{"location":"api/#BlochSimulators.AbstractTrajectory","page":"API","title":"BlochSimulators.AbstractTrajectory","text":"AbstractTrajectory\n\nThe abstract type of which all gradient trajectories will be a subtype. The subtypes should contain fields that can describe the full trajectory during a sequence.\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.SpokesTrajectory","page":"API","title":"BlochSimulators.SpokesTrajectory","text":"SpokesTrajectory <: AbstractTrajectory\n\nTypical Cartesian and radial trajectories have a lot in common: a readout can be described by a starting point in k-space and a Δk per sample point. To avoid code repetition, both type of trajectories are made a subtype of SpokesTrajectory such that some methods that would be the same for both trajectories otherwise are written for SpokesTrajectory instead.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interface-2","page":"API","title":"Interface","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"trajectories/_interface.jl\"]","category":"page"},{"location":"api/#BlochSimulators._get_readout_and_sample_idx-Tuple{Any, Any}","page":"API","title":"BlochSimulators._get_readout_and_sample_idx","text":"_get_readout_and_sample_idx(trajectory, t)\n\nGiven time index t, compute the associated readout and sample indices (r,s). For trajectories where each readout has the same length, this is equivalent to r,s = fld1(t,ns), mod1(t,ns) with ns being the (constant) number of samples per readout.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.nreadouts-Tuple{AbstractTrajectory}","page":"API","title":"BlochSimulators.nreadouts","text":"nreadouts(::AbstractTrajectory)\n\nFor each ::AbstractTrajectory, a method should be added to this function that specifies how many readouts the trajectory consists of.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.nsamples-Tuple{AbstractTrajectory}","page":"API","title":"BlochSimulators.nsamples","text":"nsamples(trajectory::AbstractTrajectory)\n\nDetermines the total number of samples acquired with the trajectory. Requires nreadouts and nsamplesperreadout to be implemented.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.nsamplesperreadout-Tuple{AbstractTrajectory, Any}","page":"API","title":"BlochSimulators.nsamplesperreadout","text":"nsamplesperreadout(::AbstractTrajectory, readout_idx)\n\nFor each ::AbstractTrajectory, a method should be added to this function that specifies how many samples in total are acquired during the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.phase_encoding!-Tuple{Any, AbstractTrajectory, Any}","page":"API","title":"BlochSimulators.phase_encoding!","text":"phase_encoding!(echos, trajectory::AbstractTrajectory, parameters)\n\nFor each ::AbstractTrajectory, a method should be added to this function if it does any kind of phase encoding (so far Cartesian only).\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.to_sample_point-NTuple{5, Any}","page":"API","title":"BlochSimulators.to_sample_point","text":"to_sample_point(m, trajectory, readout_idx, sample_idx, parameters)\n\nFor each ::AbstractTrajectory, a method should be added to this function that, given the magnetization m at the readout with index readout_idx, it computes the magnetization at the readout point with index sample_idx (by applying spatial encoding gradients, T₂ decay, B₀ rotation, etc...) based on the trajectory and parameters.\n\nArguments\n\nm:              Magnetization at the echo with index readout_idx.\ntrajectory:     Trajectory struct containing fields that are used to compute the magnetization at other readout times,                   including the effects of spatial encoding gradients.\nreadout_idx:    Index that corresponds to the current readout.\nsample_idx:     Index for the desired sample during this readout.\nparameters:     Tissue parameters of current voxel, including spatial coordinates.\n\nOutput:\n\nmₛ:   Magnetization at sample with index sample_idx\n\n\n\n\n\n","category":"method"},{"location":"api/#Examples-2","page":"API","title":"Examples","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"trajectories/cartesian.jl\", \"trajectories/radial.jl\", \"trajectories/spiral.jl\"]","category":"page"},{"location":"api/#BlochSimulators.CartesianTrajectory","page":"API","title":"BlochSimulators.CartesianTrajectory","text":"CartesianTrajectory{T,I,U,V} <: SpokesTrajectory\n\nStruct that is used to implement a typical Cartesian gradient trajectory. The trajectory is described in a compact fashion by only storing the starting position in k-space (k_start_readout) for each readout as well as the step in k-space per readout point Δk_adc.\n\nNote that CartesianTrajectory and RadialTrajectory are essentially the same in when using when using this compact description. A SpokesTrajectory struct is therefore defined as a supertype of both and methods are defined for SpokesTrajectory instead to avoid code repetition.\n\nThe type parameters are intentionally left vague. The J, for example, may be an integer for sequences where each readout has the same number of samples, but for sequences with different numbers of samples per readout it may be a vector of integers.\n\nFields\n\nnreadouts::I: The total number of readouts for this trajectory\nnsamplesperreadout::I: The total number of samples per readout\nΔt::T: Time between sample points\nk_start_readout::U: Starting position in k-space for each readout\nΔk_adc::U: k-space step Δkₓ per sample point (same for all readouts)\npy::V: Phase encoding index for each readout\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.kspace_coordinates-Tuple{CartesianTrajectory}","page":"API","title":"BlochSimulators.kspace_coordinates","text":"kspace_coordinates(tr::CartesianTrajectory)\n\nReturn matrix (nrsamplesperreadout, nrreadouts) with kspace coordinates for the trajectory. Needed for nuFFT reconstructions.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.sampling_mask-Tuple{CartesianTrajectory}","page":"API","title":"BlochSimulators.sampling_mask","text":"sampling_mask(tr::CartesianTrajectory)\n\nFor undersampled Cartesian trajectories, the gradient trajectory can also be described by a sampling mask.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.RadialTrajectory","page":"API","title":"BlochSimulators.RadialTrajectory","text":"RadialTrajectory{T,I,U,V} <: SpokesTrajectory\n\nStruct that is used to implement a typical radial gradient trajectory. The trajectory can is described in a compact fashion by only storing the starting position in k-space (k_start_readout) for each readout as well as the step in k-space per readout point Δk_adc.\n\nNote that CartesianTrajectory and RadialTrajectory are essentially the same in when using when using this compact description. A SpokesTrajectory struct is therefore defined as a supertype of both and methods are defined for SpokesTrajectory instead to avoid code repetition.\n\nThe type parameters are intentionally left vague. The J, for example, may be an integer for sequences where each readout has the same number of samples, but for sequences with different numbers of samples per readout it may be a vector of integers.\n\nFields\n\nnreadouts::I: The total number of readouts for this trajectory\nnsamplesperreadout::I: The total number of samples per readout\nΔt::T: Time between sample points\nk_start_readout::U: Starting position in k-space for each readout\nΔk_adc::U: k-space step Δk between each readout\nφ::V: Radial angle for each readout\n\n\n\n\n\n","category":"type"},{"location":"api/#BlochSimulators.add_gradient_delay!-Tuple{RadialTrajectory, Any}","page":"API","title":"BlochSimulators.add_gradient_delay!","text":"add_gradient_delay!(tr::RadialTrajectory, S)\n\nApply gradient delay to radial trajectory in in-place fashion. The delay is described by the 2x2 matrix S and is assumed to influence the start of the readout only, not the readout direction.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.kspace_coordinates-Tuple{RadialTrajectory}","page":"API","title":"BlochSimulators.kspace_coordinates","text":"kspace_coordinates(tr::RadialTrajectory)\n\nReturn matrix (nrsamplesperreadout, nrreadouts) with kspace coordinates for the trajectory. Needed for nuFFT reconstructions.\n\n\n\n\n\n","category":"method"},{"location":"api/#Dictionary-Simulation","page":"API","title":"Dictionary Simulation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"simulate_echos(resource, sequence, parameters)","category":"page"},{"location":"api/#BlochSimulators.simulate_echos-Tuple{Any, Any, Any}","page":"API","title":"BlochSimulators.simulate_echos","text":"simulate_echos(resource, sequence, parameters)\n\nSimulate the magnetization at echo times (without any spatial encoding gradients applied) for all combinations of tissue parameters contained in parameters.\n\nThis function can also be used to generate dictionaries for MR Fingerprinting purposes.\n\nArguments\n\nresource::AbstractResource: Either CPU1(), CPUThreads(), CPUProcesses() or CUDALibs()\nsequence::BlochSimulator: Custom sequence struct\nparameters::AbstractVector{<:AbstractTissueParameters}: Vector with different combinations of tissue parameters\n\nReturns\n\noutput::AbstractArray: Array of size (output_dimensions(sequence), length(parameters)) containing the   magnetization at echo times for all combinations of input tissue parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"simulate/echos.jl\"]","category":"page"},{"location":"api/#BlochSimulators._allocate_output-Tuple{Any, BlochSimulator, Any}","page":"API","title":"BlochSimulators._allocate_output","text":"_allocate_output(resource, sequence::BlochSimulator, parameters)\n\nAllocate an array to store the output of the Bloch simulations (per voxel, echo times only) to be performed with the sequence. For each BlochSimulator, methods should have been added to output_eltype and output_dimensions for this function to work properly.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.simulate_echos-Tuple{ComputationalResources.CPU1, Any, Any}","page":"API","title":"BlochSimulators.simulate_echos","text":"simulate_echos(::CPU1, sequence, parameters)\n\nPerform simulations on a single CPU by looping over all entries of parameters and performing Bloch simulations for each combination of tissue parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.simulate_echos-Tuple{ComputationalResources.CPUProcesses, Any, DistributedArrays.DArray}","page":"API","title":"BlochSimulators.simulate_echos","text":"simulate_echos(::CPUProcesses, sequence, dparameters::DArray)\n\nPerform simulations using multiple, distributed CPUs. See the Julia documentation and the DistributedArrays package for more details on how to use Julia with multiple workers.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.simulate_echos-Tuple{ComputationalResources.CPUThreads, Any, Any}","page":"API","title":"BlochSimulators.simulate_echos","text":"simulate_echos(::CPUThreads, sequence, parameters)\n\nPerform simulations by looping over all entries of parameters in a multi-threaded fashion. See the Julia documentation for more details on how to launch Julia with multiple threads of execution.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.simulate_echos-Tuple{ComputationalResources.CUDALibs, Any, CUDA.CuArray}","page":"API","title":"BlochSimulators.simulate_echos","text":"simulate_echos(::CUDALibs, sequence, parameters::CuArray)\n\nPerform simulations on NVIDIA GPU hardware by making use of the CUDA.jl package. Each thread perform Bloch simulations for a single entry of the parameters array.\n\n\n\n\n\n","category":"method"},{"location":"api/#Signal-Simulation","page":"API","title":"Signal Simulation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"simulate_signal(resource, sequence, parameters, trajectory, coil_sensitivities)","category":"page"},{"location":"api/#BlochSimulators.simulate_signal-NTuple{5, Any}","page":"API","title":"BlochSimulators.simulate_signal","text":"simulate_signal(resource, sequence, parameters, trajectory, coil_sensitivities)\n\nSimulate the MR signal at timepoint t from coil i as: sᵢ(t) = ∑ⱼ cᵢⱼρⱼmⱼ(t), where cᵢⱼis the coil sensitivity of coil i at position of voxel j, ρⱼ is the proton density of voxel j and mⱼ(t) the (normalized) transverse magnetization in voxel j obtained through Bloch simulations.\n\nArguments\n\nresource::AbstractResource: Either CPU1(), CPUThreads(), CPUProcesses() or CUDALibs()\nsequence::BlochSimulator: Custom sequence struct\nparameters::AbstractVector{<:AbstractTissueParameters}: Vector with tissue parameters for each voxel\ntrajectory::AbstractTrajectory: Custom trajectory struct\ncoil_sensitivities::AbstractVector{<:SVector{ncoils}}: Vector with ncoils coil sensitivities for each voxel\n\nReturns\n\nsignal::Vector{<:SVector{ncoils}}: Simulated MR signal for the sequence and trajectory.\n\nAt each timepoint, the signal for each of the ncoils is stored.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"simulate/signal.jl\"]","category":"page"},{"location":"api/#BlochSimulators._allocate_signal_output-Union{Tuple{T}, Tuple{Any, AbstractTrajectory, AbstractVector{T}}} where T<:(StaticArraysCore.SVector)","page":"API","title":"BlochSimulators._allocate_signal_output","text":"_allocate_signal_output(resource, trajectory::AbstractTrajectory, coil_sensitivities)\n\nAllocate an array to store the output of the signal simulation (all readout points, integrated over all voxels).\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.echos_to_signal-NTuple{5, Any}","page":"API","title":"BlochSimulators.echos_to_signal","text":"echos_to_signal(resource, echos, parameters, trajectory, coil_sensitivities)\n\nGiven the magnetization at echo times in all voxels, allocate memory for the signal output on CPU, then loop over all time points t and use the (generic) echos_to_signal! implementation to compute the signal for that time point.\n\nThis loop order is not necessarily optimal (and performance may be) across all trajectories and computational resources. If a better implementation is available, add new methods to this function for those specific combinations of resources and trajectories.\n\n\n\n\n\n","category":"method"},{"location":"api/#Utility-Functions","page":"API","title":"Utility Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [BlochSimulators]\nPages   = [\"utils/precision.jl\", \"utils/gpu.jl\"]","category":"page"},{"location":"api/#BlochSimulators.f32-Tuple{Any}","page":"API","title":"BlochSimulators.f32","text":"f32(x)\n\nChange precision of x to Float32. It uses Functors.fmap to recursively traverse the fields of the struct x. For custom structs (e.g. <:BlochSimulator or <:AbstractTrajectory), it is required that typeof(x) be made a Functors.@functor (e.g. @functor FISP).\n\nIt may be necessary to add new adapt rules (by adding new methods to adapt_storage) if new structs with complicated nested fields are introduced.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.f64-Tuple{Any}","page":"API","title":"BlochSimulators.f64","text":"f64(x)\n\nChange precision of x to Float64. It uses Functors.fmap to recursively traverse the fields of the struct x. For custom structs (e.g. <:BlochSimulator or <:AbstractTrajectory), it is required that typeof(x) be made a Functors.@functor (e.g. @functor FISP).\n\nIt may be necessary to add new adapt rules (by adding new methods to adapt_storage) if new structs with complicated nested fields are introduced.\n\n\n\n\n\n","category":"method"},{"location":"api/#BlochSimulators.gpu-Tuple{Any}","page":"API","title":"BlochSimulators.gpu","text":"gpu(x)\n\nMove x to CUDA device. It uses Functors.fmap to recursively traverse the fields of the struct x, converting <:AbstractArrays to CuArrays, and ignoring isbitsarrays. For custom structs (e.g. <:BlochSimulator or <:AbstractTrajectory), it is required that typeof(x) be made a Functors.@functor (e.g. @functor FISP).\n\n\n\n\n\n","category":"method"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"CurrentModule = BlochSimulators","category":"page"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/#MR-Signal-Equation","page":"Overview","title":"MR Signal Equation","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"In Magnetic Resonance Imaging (MRI), the complex signal s at time point t of a pulse sequence can be modelled as","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"s(t) = int_V c(vecr)m_perp(vecrt)dvecr.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Here c is the spatially-dependent receive sensitivity of the coil used for signal reception, V is field-of-view of the receive coil and m_perp(vecrt) is the (complex) transverse magnetization at the spatial location vecr at time point t.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The dynamical behaviour of the magnetization is described by the Bloch equations and depends on the pulse sequence used in the acquisition, tissue parameters (e.g. T_1, T_2 and proton density) and system parameters (e.g. Delta B_0 and B_{1}^{+} inhomogeneities). Given a pulse sequence as well as tissue- and system parameters in a voxel with spatial location vecr, the transverse magnetization m_perp(rt) at arbitrary time points t can be obtained by numerical integration of the Bloch equations (i.e. Bloch simulations). Note that m_perp(vecrt) can in fact be separated as","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"m_perp(vecrt) = m(vecrt)e^-2pi i veck(t)cdot vecr,","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"where m is the transverse magnetization without any (in-plane / in-slab) gradient encoding, and veck(t) is the gradient trajectory used in the acquisition. That is, m and the gradient encoding e^-2pi i veck(t)cdot vecr can be computed separately.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"To simulate s in practice, spatial discretization must first be performed. Divide the field-of-view into N_v voxels spatial coordinates vecr_1 ldots vecr_N_v. Assume each voxel to have the same volume Delta V. The signal s(t) is then computed as the discrete sum","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"s(t) = sum_j=1^N_v c(vecr_j)m(vecr_jt)e^-2pi i veck(t)cdot vecr_j Delta V.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"BlochSimulators provides tools to perform Bloch simulations (i.e. numerical integration of the Bloch equations) for computing m and to evaluate the discrete sum required for computing the signal s at desired sample times.","category":"page"},{"location":"overview/#Design-philosophy","page":"Overview","title":"Design philosophy","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Whereas other Bloch simulation toolboxes typically provide a single, generic simulator that can be used for arbitrary pulse sequences, with BlochSimulators one is encouraged to assemble pulse sequence-specific simulators. The philosophy behind this design choice is that sequence-specific simulators can incorporate knowledge of repetitive patterns in pulse sequence (e.g. RF excitation waveform and/or gradient waveforms) to improve the runtime performance of the simulator.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"A second important design philosophy is that, when one intends to simulate MR signal for some numerical phantom, first the magnetization m at echo times in all voxels is computed (without taking into account the effects of the gradient trajectory). If m_e is the transverse magnetization in one voxel at some echo time of the pulse sequence, then the transverse magnetization at the j-th sample point of that readout relative to the echo time can be computed analytically as","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"m_s = m_e left(e^-fracDelta tT_2 e^-2pi i Delta B_0right)^j e^-2pi i veck(t) cdot vecr,","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"where Delta t is the time between sample points of the readout.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Given m at echo times, the signal s is thus computed by expanding the magnetization to all sample times and evaluating the discrete sum while taking into account the gradient trajectory (and coil sensitivities).","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Note that the (discretized) signal equation closely resembles a Discrete Fourier Transform. In many MRI applications, the Fast Fourier Transform (FFT) is used to transform back-and-forth between the image domain and the k-space domain. In BlochSimulators, we intentionally do not rely on the FFT since it does not allow to take into account dynamical behaviour during readouts (e.g. T_2 decay and/or Delta B_0-induced rotations).","category":"page"},{"location":"overview/#Simulating-magnetization-at-echo-times","page":"Overview","title":"Simulating magnetization at echo times","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"BlochSimulators supports two different models for performing Bloch simulations: the individual isochromat model and the extended phase graph model. For both models, basic operator functions are implemented (see src/operators/isochromat.jl and src/operators/epg.jl) in a type-stable and non-allocating fashion. By combining these operators, simulators for entire pulse sequences can be assembled. To this end, a user must define a new Struct that is a subtype of either IsochromatSimulator or EPGSimulator with fields that are necessary to describe the pulse sequence (e.g. flip angle(s), TR, TE, etc.). A method must then be added for this new type to the simulate_echos! function which, by combining the fields of the struct with the basic operators, implements the magnetization response of the sequence. See src/sequences/_interface.jl for additional information and requirements.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"To perform simulations, tissue parameter inputs must be provided. Custom structs for different combinations of tissue parameters are introduced in this package (all of which are subtypes of AbstractTissueParameters). See src/parameters/tissueparameters.jl for more information.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Given a sequence struct together with a set of input parameters  for each voxel (currently the parameters must be an ::AbstractArray{<:AbstractTissueParameters}), the magnetization at echo times in each voxel is obtained with the function call","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"echos = simulate_echos(resource, sequence, parameters),","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"where resource is either CPU1(), CPUThreads(), CPUProcesses() or CUDALibs() (see ComputationalResources.jl). This function can also be used in the context of MR Fingerprinting to generate a dictionary.","category":"page"},{"location":"overview/#Simulating-the-MR-signal","page":"Overview","title":"Simulating the MR signal","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"To compute the MR signal s given the magnetization at echo times in all voxels, the echos_to_signal function is used (see  src/simulate/signal.jl). By default, for each timepoint t a function echos_to_signal! is called internally which computes the magnetization at sample time t for each voxel and evaluates the volume integral","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"sum_j=1^N_v c(vecr_j)m(vecr_jt)e^-2pi i veck(t)cdot vecr_j Delta V.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"In order to evaluate the above expression, information from the gradient trajectory (i.e. k(t)) is required. For each different type of trajectory, a new struct (subtype of AbstractTrajectory) must be introduced with fields that describe that particular gradient trajectory. A new method must then be added to the to_sample_point function which is used to compute","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"m(vecr_jt)e^-2pi i veck(t)cdot vecr_j","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"for sample points other than the echo times. See src/trajectories/_interface.jl for more details. Example implementations for Cartesian and radial trajectories are provided.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Given the magnetization at echo times in all voxels (stored in echos), the signal s at sample times is computed with the function call","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"signal = echos_to_signal(resource, echos, parameters, trajectory, coil_sensitivities).","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Alternatively, the signal can be computed with the simulate function as","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"signal = simulate_signal(resource, sequence, parameters, trajectory, coil_sensitivities).","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"We note that the implementation of to_sample_point for a new trajectory should be type-stable and non-allocating. In that case, the signal computation will likely run on different computational resources following the echos_to_signal implementation. In the default implementation echos_to_signal, different compute threads (i.e. when running in multi-threaded mode or in GPU) are assigned to different sample times. The benefit of this approach is that no communication between threads is required. However, from a memory-access point-of-view this approach may not necessarily be optimal. The optimal approach may depend on the actual gradient trajectory and computational resource. If more \"optimal\" implementations are discovered, methods may be be added echos_to_signal to use more optimized implementations for specific combinations of trajectories and resources.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"(Image: BlochSimulators.jl graphical overview )","category":"page"},{"location":"overview/#GPU-Compatibility","page":"Overview","title":"GPU Compatibility","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The operator functions for both the isochromat model and the extended phase graph model have been designed to be type-stable and non-allocating. A proper combination of these operators should make it possible to have type-stable and non-allocating simulations for entire pulse sequences. Besides being beneficial for performance on CPU hardware, this also makes it possible to run simulations on GPU cards (NVIDIA) using the CUDA.jl.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"To run simulations on a GPU card, the sequence, trajectory, parameters and coil_sensitivities must be sent to the GPU first. For this purpose, a convenience function gpu is exported.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Also note that by default, Julia arrays have double precision (Float64 or ComplexF64) upon construction. To convert to single precision (Float32), a convenience function f32 is exported as well.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"For example, given some sequence, gpu(f32(sequence)) will recursively convert its fields to single precision and convert any regular Arrays to CuArrays.","category":"page"},{"location":"overview/#Todo","page":"Overview","title":"Todo","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"For 3D applications, storing the magnetization at echo times for all voxels may not be feasible. The computations can be performed in batches though but such batching is currently not implemented.\nAdd diffusion operators to both the isochromat and extended phase graph models.\nAdd magnetization transfer model.\nAdd spiral and EPI trajectories.\nStore parameters as StructArray rather than AbstractArray{<:AbstractTissueParameters}. \nPerhaps separate the spatial coordinates from the tissue parameters.","category":"page"},{"location":"dictionary/#MR-Fingerprinting-Dictionary-Generation","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"","category":"section"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"In this example we demonstrate how to generate an MR Fingerprinting dictionary using a FISP type sequence","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"using BlochSimulators\nusing ComputationalResources","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"First, construct a FISP sequence struct (see src/sequences/fisp.jl for which fields are necessary and which constructors exist)","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"nTR = 1000; # nr of TRs used in the simulation\nRF_train = LinRange(1,90,nTR) |> collect; # flip angle train\nTR,TE,TI = 0.010, 0.005, 0.100; # repetition time, echo time, inversion delay\nmax_state = 25; # maximum number of configuration states to keep track of\n\nsequence = FISP(RF_train, TR, TE, max_state, TI);","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"Next, set the desired input parameters","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"T₁ = 0.500:0.010:5.0; # T₁ range\nT₂ = 0.025:0.005:1.0; # T₂ range\n\nparameters = map(T₁T₂, Iterators.product(T₁,T₂)); # produce all parameter pairs\nparameters = filter(p -> (p.T₁ > p.T₂), parameters); # remove pairs with T₂ ≤ T₁","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"Now we can perform the simulations using different hardware resources","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"Note that the first time a function is called in a Julia session, a precompilation procedure starts and the runtime for subsequent function calls are significantly faster","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"First, we simply simulate a dictionary using single-threaded CPU mode:","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"@time dictionary = simulate_echos(CPU1(), sequence, parameters);\n@time dictionary = simulate_echos(CPU1(), sequence, parameters);","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"To use multiple threads, Julia must be started with the --threads=auto flag (or some integer instead of auto). Then, we can simulate in a multi-threaded fashion with the following syntax:","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"@time dictionary = simulate_echos(CPUThreads(), sequence, parameters);\n@time dictionary = simulate_echos(CPUThreads(), sequence, parameters);","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"For distributed CPU mode, use the Distribute packages (ships with Julia) to add workers first","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"using Distributed\naddprocs(4, exeflags=\"--project=.\")","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"Alternatively, if you can ssh into some other machine, you can add CPUs from that machine as follows:","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"addprocs([(\"12.345.67.89\", 4)], exeflags=\"--project=.\")","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"Or, if you want to run this code on cluster with a queuing system, use ClusterManagers package.","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"After workers have been added, load BlochSimulators on all workers and then start a distributed dictionary generation with:","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"@everywhere using BlochSimulators\n\n@time dictionary = simulate_echos(CPUProcesses(), sequence, parameters);\n@time dictionary = simulate_echos(CPUProcesses(), sequence, parameters);","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"To perform simulations on GPU, we first convert the sequence and parameters to single precision and then send them to the gpu","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"cu_sequence = sequence |> f32 |> gpu;\ncu_parameters = parameters |> f32 |> gpu;\n\n@time dictionary = simulate_echos(CUDALibs(), cu_sequence, cu_parameters);\n@time dictionary = simulate_echos(CUDALibs(), cu_sequence, cu_parameters);","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"","category":"page"},{"location":"dictionary/","page":"MR Fingerprinting Dictionary Generation","title":"MR Fingerprinting Dictionary Generation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = BlochSimulators","category":"page"},{"location":"#BlochSimulators","page":"Home","title":"BlochSimulators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BlochSimulators is a Julia package for performing Bloch simulations within the context of Magnetic Resonance Imaging. It allows one to build custom sequence and trajectory structs to perform MR signal simulations on different computational resources, including CUDA compatible GPU cards. The development aim of package was to achieve the highest possible runtime performance. The package can be used to simulate dictionaries for MR Fingerprinting or to perform forward model evaluations for MR-STAT.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BlochSimulators is registered in the General Julia registry. To install the package, enter the Pkg REPL by pressing ], followed by either","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add BlochSimulators (if you want to use the package as-is)","category":"page"},{"location":"","page":"Home","title":"Home","text":"or ","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> dev BlochSimulators (if you want to make modificatios to the source code).","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See CITATION.bib for details on how to cite this work.","category":"page"}]
}
